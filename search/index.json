[{"content":"Python 异步编程 asyncio模块 asyncio 模块在单线程上启动一个事件循环（event loop），时刻监听新进入循环的事件，加以处理，并不断重复这个过程，直到异步任务结束。\n1 2  import asyncio async def main():   async 函数前面加上async关键字，就变成了异步函数。这种函数最大的特点就是 执行可以暂停，交出执行权。\nawait 在异步函数内部的异步任务前面，加上await命令。 await asyncio.sleep(1) asyncio.sleep(1)可以生成一个异步任务，休眠1秒钟，然后结束。\n执行引擎遇到await命令，就会在异步任务开始执行之后，暂停当前 async 函数的执行，把执行权交给其他任务。等到异步任务结束，再把执行权交回 async 函数，继续往下执行。\nasync.run() async.run()用于加载async函数，启动事件循环。 asyncio.run(main())\n上面代码中，asyncio.run() 在事件循环上监听 async 函数main的执行。等到 main 执行完了，事件循环才会终止。\n示例 1 2 3 4 5 6 7 8 9 10 11 12  import asyncio async def count(): print(\u0026#34;One\u0026#34;) await asyncio.sleep(1) print(\u0026#34;Two\u0026#34;) async def main(): await asyncio.gather(count(), count(), count()) asyncio.run(main())   上面脚本中，在 async 函数main的里面，asyncio.gather() 方法将多个异步任务（三个 count()）包装成一个新的异步任务，必须等到内部的多个异步任务都执行结束，这个新的异步任务才会结束。\n脚本的运行结果如下：\n1 2 3 4 5 6  One One One Two Two Two   上面运行结果的原因是，三个 count() 依次执行，打印完 One，就休眠1秒钟，把执行权交给下一个 count()，所以先连续打印出三个 One。等到1秒钟休眠结束，执行权重新交回第一个 count()，开始执行 await 命令下一行的语句，所以会接着打印出三个Two。脚本总的运行时间是1秒。\n作为对比，下面的同步版本：\n1 2 3 4 5 6 7 8 9 10 11 12  import time def count(): print(\u0026#34;One\u0026#34;) time.sleep(1) print(\u0026#34;Two\u0026#34;) def main(): for _ in range(3): count() main()   上面脚本的运行结果如下:\n1 2 3 4 5 6  One Two One Two One Two   上面运行结果的原因是，三个 count() 都是同步执行，必须等到前一个执行完，才能执行后一个。脚本总的运行时间是3秒。\npyppeteer 执行多个函数中的多个异步任务时，异步任务切换时，你不知道会切换到哪个函数中的异步任务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import asyncio from pyppeteer import launch async def screen_shot_1(): browser = await launch() page = await browser.newPage() await page.goto(\u0026#39;https://fastapi.tiangolo.com/zh/tutorial/middleware/\u0026#39;) await page.screenshot({\u0026#39;path\u0026#39;: \u0026#39;1.png\u0026#39;}) await browser.close() async def screen_shot_2(): browser = await launch() page = await browser.newPage() await page.goto(\u0026#39;https://www.ruanyifeng.com/blog/2019/11/python-asyncio.html\u0026#39;) await page.screenshot({\u0026#39;path\u0026#39;: \u0026#39;2.png\u0026#39;}) await browser.close() async def main(): await asyncio.gather(screen_shot_1(), screen_shot_2()) asyncio.run(main())   ","date":"2023-06-26T00:00:00Z","permalink":"https://jhrsya.github.io/p/python%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/","title":"python异步编程"},{"content":"solidity solidity 定义变量 1 2 3 4 5 6  // 无类型变量 var variableName; // 声明和初始化有类型变量 type variableName = value;   其中，type是变量的数据类型，例如uint、address、string等，variableName是变量的名称。\n定义常量 常量使用constant或immutable关键字声明，并在声明时进行初始化。它们的值在合约部署后无法修改。\n1 2 3 4 5  // 常量声明和初始化 constant type constantName = value; constant uint constantNumber = 42;   定义函数 1 2 3 4 5 6  // 函数声明 function functionName(parameter1, parameter2, ...) [visibility] [modifiers] [returns (type)] { // 函数体  // 可选返回语句 }   其中，functionName是函数的名称，parameter1, parameter2, \u0026hellip;是函数的参数列表，visibility是函数的可见性（例如public、private、internal、external），modifiers是函数修饰符，用于修改函数行为（例如view、pure），returns (type)是函数的返回类型（可选）。 例如：\n1 2 3 4 5  // 声明一个公共函数add，接受两个uint类型的参数并返回它们的和 function add(uint a, uint b) public returns (uint) { return a + b; }   定义类（合约） Solidity中的类通常被称为“合约”（Contracts），合约是包含状态变量、函数和事件等的代码单元。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 合约声明 contract ContractName { // 状态变量  type public variableName; // 构造函数  constructor(parameter1, parameter2, ...) { // 构造函数体  } // 函数  function functionName(parameter1, parameter2, ...) [visibility] [modifiers] [returns (type)] { // 函数体  // 可选返回语句  } }   其中，ContractName是合约的名称，variableName是合约的状态变量，constructor是合约的构造函数（可选），functionName是合约的函数。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12  contract MyContract { uint public myVariable; constructor() { myVariable = 10; } function setVariable(uint newValue) public { myVariable = newValue; } }   定义结构体 1 2 3 4  struct Person { uint age; string name; }   定义数组 1 2 3 4 5 6  uint[] public myList; uint value = 3; myList.push(value); // 往数组中添加元素的方法  // 获取数组的下标 uint id = myList.push(value) - 1;   定义字典 1 2 3  mapping(string =\u0026gt; uint) public myDict; unit value = 4; myDict[key] = value;   memory关键字 memory是一个关键字，用于声明临时内存变量。它主要用于函数参数和临时变量，特别是在处理大量数据时非常有用。\n当在函数参数中使用memory关键字时，表示该参数的值将被复制到临时内存中，并在函数执行完毕后被销毁。这对于字符串、数组和结构体等动态大小的数据类型非常有用，因为它们的大小在编译时是未知的。\n以下是一些使用memory关键字的常见情况：\n 函数参数：对于需要传递大量数据的函数，将参数声明为memory类型可以避免将数据存储在存储器中，从而减少燃料消耗和交易成本。  1 2 3 4 5  function processArray(uint[] memory data) public { // 在内存中处理数据  // ... }   结构体和数组临时变量：在函数内部声明结构体和数组时，可以使用memory关键字将其分配到临时内存中。  1 2 3 4 5  function processArray(uint[] memory data) public { uint[] memory tempArray = new uint[](data.length); // 在内存中操作tempArray  // ... }   需要注意的是，memory关键字只能用于值类型数据，而不能用于引用类型（例如storage）或指针类型。此外，memory中的数据无法在智能合约的不同函数之间保持持久性，因为它们在函数执行完毕后会被销毁。\n总结：memory关键字在Solidity中用于声明临时内存变量，特别适用于处理动态大小的数据类型。它可以减少存储器使用、优化燃料消耗，并降低交易成本。\nsolidity中变量存储在存储器中的作用 变量可以存储在不同的位置，包括存储器（storage）、内存（memory）和栈（stack）。每个位置都具有不同的特性和用途。\n当变量存储在存储器中时，它具有以下特点和作用：\n  持久性存储：存储器是永久性的，它的值会一直存在于智能合约的存储空间中，直到被显式地修改或删除。这意味着在不同的函数调用之间，存储在存储器中的变量的值是持久的。\n  共享数据：存储器中的变量可以被智能合约的所有函数访问。这使得存储器非常适合存储合约状态、用户余额、合约配置等需要在整个合约中共享和持久化的数据。\n  高成本：将变量存储在存储器中需要更高的燃料成本和交易成本，因为这涉及写入区块链的状态存储。对存储器的频繁读写操作可能会增加智能合约的执行成本。\n  指针访问：通过引用（指针）方式访问存储器中的变量。这意味着在函数调用中传递存储器中的变量时，实际上是传递了一个指向该变量的指针，而不是复制整个变量的内容。这样可以节省内存和计算资源。\n  存储器是Solidity中一种用于持久性存储和共享数据的位置。它适用于需要在整个合约中访问和修改的数据，但要注意高昂的成本和资源消耗。在选择变量存储位置时，需要根据具体需求平衡持久性、成本和访问速度等因素。\n函数何时存储在存储器中 在Solidity中，变量的存储位置是根据其声明方式和上下文环境自动确定的。以下是一些影响变量存储位置的要点：\n 合约状态变量：合约中声明的状态变量（即合约级别的变量）默认存储在存储器中。例如：  1 2 3  contract MyContract { uint public myVariable; // 存储在存储器中，函数外 }   函数参数和返回值：函数参数和返回值的存储位置可以使用关键字进行显式声明。   memory关键字：使用memory关键字声明的参数和返回值存储在临时内存中，用于处理动态大小的数据类型（如字符串、数组和结构体）。  1 2 3 4  function myFunction(uint[] memory myArray) public returns (uint[] memory) { // 函数体 }    storage关键字：使用storage关键字声明的参数和返回值存储在存储器中，用于对状态变量进行引用。  1 2 3  function myFunction(uint[] storage myArray) public returns (uint[] storage) { // 函数体 }   局部变量：局部变量的存储位置在编译时自动确定，取决于其类型和使用方式。如果局部变量是引用类型（如结构体、数组或映射）并且没有使用关键字声明存储位置，它们将默认存储在存储器中。对于其他类型的局部变量，它们通常存储在栈上。  1 2 3 4  function myFunction() public { uint[] memory myArray = new uint[](5); // 存储在存储器中  uint myNumber = 10; // 存储在栈上 }   需要注意的是，在函数内部声明的局部变量在函数执行完毕后会被销毁，无法持久保存。\n总结：变量的存储位置是根据声明方式和上下文环境自动确定的。合约状态变量默认存储在存储器中，函数参数和返回值可以使用memory和storage关键字显式声明存储位置，而局部变量的存储位置在编译时自动确定，通常根据类型和使用方式进行推断。\n关键字view view function: 表示只能查看数据，不能修改数据。\n关键字pure pure function: 表示不能从app能访问数据。 例如：\n1 2 3  function _multiply(uint a, uint b) private pure returns (uint) { return a * b; }   关键字event event关键字用于定义合约中的事件。事件是一种在合约中发生的、可以被外部观察的事情。通过定义事件，合约可以将重要的状态变化或操作结果通知给外部世界。\n事件可以被视为合约与外部世界之间的通信机制。当某个合约中定义的事件被触发时，它将生成一个事件日志，该日志可以被其他合约、dApp或外部工具监听和读取。\n事件通常用于以下几个方面：\n  通知状态变化：当合约的某个状态发生变化时，通过触发事件可以通知其他合约或前端应用程序。这样，外部实体就可以及时获知合约中重要的状态变化，而无需主动轮询合约状态。\n  事件溯源：通过在关键操作发生时触发事件，可以在区块链上创建一个不可篡改的事件日志。这对于审计和溯源非常有用，因为所有的事件都会被记录在区块链上，不可更改。\n  前端通信：前端应用程序可以通过监听事件来响应合约中的变化，并及时更新用户界面。这样，用户可以实时获取合约的交互结果，提供更好的用户体验。\n  以下是一个简单的Solidity事件定义的例子：\n1 2 3 4 5 6 7 8 9 10  pragma solidity ^0.8.0; contract MyContract { event MyEvent(address indexed sender, uint256 value); function myFunction(uint256 _value) public { // 执行一些操作  emit MyEvent(msg.sender, _value); } }   在上述示例中，MyEvent是一个事件，它有两个参数：sender和value。emit关键字用于触发事件，并将相关参数的值传递给事件日志。在该合约中，每当myFunction函数被调用时，都会触发MyEvent事件，并记录调用者的地址和传入的值。\n请注意，事件的定义并不会被调用方执行，它只是一个定义，用于指定事件的结构和参数。事件的触发必须在合约的函数中通过emit关键字显式调用。\nmsg.sender 是地址的引用，哪个账户调用这个函数，msg.sender就是这个账户的地址。\n关键字require 1 2 3 4 5 6 7 8  function sayHiToVitalik(string memory _name) public returns (string memory) { // Compares if _name equals \u0026#34;Vitalik\u0026#34;. Throws an error and exits if not true.  // (Side note: Solidity doesn\u0026#39;t have native string comparison, so we  // compare their keccak256 hashes to see if the strings are equal)  require(keccak256(abi.encodePacked(_name)) == keccak256(abi.encodePacked(\u0026#34;Vitalik\u0026#34;))); // If it\u0026#39;s true, proceed with the function:  return \u0026#34;Hi!\u0026#34;; }   require可以用于验证require(condition)中condition条件是否成立，成立即可以调用该函数，否则会报错。\n继承 1 2 3 4 5 6 7 8 9 10 11  contract Doge { function catchphrase() public returns (string memory) { return \u0026#34;So Wow CryptoDoge\u0026#34;; } } contract BabyDoge is Doge { function anotherCatchphrase() public returns (string memory) { return \u0026#34;Such Moon BabyDoge\u0026#34;; } }   关键字internal 和 external internal关键字：子合约可以调用父合约中的internal方法。类似与private，但如果是private函数，那么子合约不能调用父合约中的private方法。 external关键字：只有在合约外部才可以调用的方法，合约内部不可以调用。类似于public。\ninterface  只调用被人的合约，只声明需要交互的函数，不需要涉及其他函数和状态变量。 只定义函数名，不定义函数体。 名称中函数有interface。  1 2 3  contract NumberInterface { function getNum(address _myAddress) public view returns (uint); }   immutability of contract 合约的不可变性，一旦合约部署在以太坊，合约就不能修改或者更新。\nOpenZeppelin库 它是一个安全的智能合约库，由社区审核，可以在自己的DApps中使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73  /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \u0026#34;user permissions\u0026#34;. */ contract Ownable { address private _owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() internal { _owner = msg.sender; emit OwnershipTransferred(address(0), _owner); } /** * @return the address of the owner. */ function owner() public view returns(address) { return _owner; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(isOwner()); _; } /** * @return true if `msg.sender` is the owner of the contract. */ function isOwner() public view returns(bool) { return msg.sender == _owner; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipTransferred(_owner, address(0)); _owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { _transferOwnership(newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function _transferOwnership(address newOwner) internal { require(newOwner != address(0)); emit OwnershipTransferred(_owner, newOwner); _owner = newOwner; } }   onlyOwner 可以设置只有owner才有能调用的函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  modifier onlyOwner() { require(isOwner()); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipTransferred(_owner, address(0)); _owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { _transferOwnership(newOwner); }   调用函数renounceOwnership时，会先执行onlyOwner函数中的代码，然后再回到renounceOwnership函数中执行其余代码。onlyOwner函数是一个修饰器函数，用于限制只有合约拥有者才能调用某些函数。在这里，它被用于确保只有合约拥有者才能调用renounceOwnership函数。\n构造函数 solidity构造函数定义方式:\n1 2 3 4  constructor() internal { _owner = msg.sender; emit OwnershipTransferred(address(0), _owner); }   它只会在合约被创建的时候执行，并只执行一次。\nmodifier function 1 2 3 4  modifier onlyOwner() { require(isOwner()); _; }   modifier函数用于修改其他函数，通常需要一些先验的检查。\ngas gas费的高低取决于函数的复杂程度和和计算资源的大小。总的gas费是每个操作gas费的总和。\n因为用户需要为每次函数调用支付gas费，所以优化代码在dapp上显得非常重要。\n为什么gas费是必要的？ 以太坊是一个巨大的，很慢的但是极度安全的计算机。当你执行一个函数时，在网络上的每一个单一节点都需要验证这个函数的输出。正是因为成千上万个节点验证函数的输出保证了以太坊的去中心化和数据不可篡改以及抗审查。\n以太坊的创建者们想要确保网络不会被无限循环的代码或者过于密集的计算所占用，所以他们让交易不是免费的，而且用户必须为计算时间和存储付费。\n节省gas费的方法 一般情况下solidity中使用uint8和uint256消耗的gas费是等价的，但是有一种例外，就是在使用struct结构体中使用uint8相对于使用uint256是更节省gas费的。 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  struct NormalStruct { uint a; uint b; uint c; } struct MiniMe { uint32 a; uint32 b; uint c; } // `mini` will cost less gas than `normal` because of struct packing NormalStruct normal = NormalStruct(10, 20, 30); MiniMe mini = MiniMe(10, 20, 30);   在Solidity中定义结构体时，将相同的数据类型聚集在一起可以最小化所需的存储空间。即一个包含字段uint c; uint32 a; uint32 b;的结构体将比一个包含字段uint32 a; uint c; uint32 b;的结构体更省gas，因为uint32字段被聚集在一起。\nview function 当用户从外部调用view函数时，不会消耗gas费。因为view函数不会修改区块链的数据，只是查看区块链的数据。\n注意：如果一个视图函数被另一个不是视图函数的函数内部调用，仍然需要花费 gas。这是因为另一个函数在以太坊上创建了一个交易，每个节点仍然需要验证该交易。因此，只有在外部调用视图函数时才是免费的。\nstorage Solidity中的存储操作是非常昂贵的，特别是写操作。每次写入或更改数据时，它都会永久写入区块链中，成为不可更改的数据。全球数千个节点需要在它们的硬盘驱动器上存储这些数据，并随着区块链的增长而不断增加。因此，这样做是有成本的。为了降低成本，我们希望除非绝对必要，否则避免将数据写入存储器。有时，这涉及看似低效的编程逻辑——例如，在每次调用函数时重新构建一个数组，而不是将该数组保存在变量中以进行快速查找。\n关键字private, public, internal, external   private修饰的函数只能被同一合约内的其他函数调用；\n  internal修饰的函数除了可以被同一合约内的其他函数调用外，还可以被继承该合约的合约调用；\n  external修饰的函数只能在合约外部被调用；\n  public修饰的函数可以在合约内外任何地方被调用。这些修饰符用于控制函数的访问权限，从而提高合约的安全性和可维护性。\n  关键字view, pure view表示函数不会修改合约中的数据，而pure表示函数既不会修改数据也不会读取数据。这两个修饰符可以使函数在被外部调用时不消耗gas（燃料），但如果被内部函数调用则会消耗gas。这是因为在内部调用时，需要将数据从存储器（storage）中读取到内存（memory）中进行操作，这需要消耗gas。\npayable modifier payable函数可以接受以太币。 可以在调用智能合约函数的同时向合约支付以太币（Ether）。这是因为在以太坊中，货币、数据和合约代码都存在于区块链上，因此可以在调用函数时同时向合约发送货币。这种特性使得一些有趣的逻辑成为可能，比如要求在执行某个函数之前向合约支付一定的货币。\n交易就像是一个信封，将函数调用中的参数比作信封中的信件内容，而添加金额则相当于在信封里放入现金，一起发送给收件人。\n1 2 3 4 5 6 7 8 9 10 11  contract OnlineStore { function buySomething() external payable { // Check to make sure 0.001 ether was sent to the function call:  require(msg.value == 0.001 ether); // If so, some logic to transfer the digital item to the caller of the function:  transferThing(msg.sender); } } // Assuming `OnlineStore` points to your contract on Ethereum: OnlineStore.buySomething({from: web3.eth.defaultAccount, value: web3.utils.toWei(0.001)})   注意：如果一个函数没有被标记为payable，你尝试去发送Ether，这个函数会拒绝你的交易。\nmsg msg.sender：调用函数的账户地址。 msg.value：可以查看有多少割以太币被发送给合约。\nwithdraw函数 当你向一个智能合约发送以太币时，它会被存储在合约的以太坊账户中，除非你添加一个提取以太币的函数，否则它将被永久锁定在合约中。\n1 2 3 4 5 6 7  contract GetPaid is Ownable { function withdraw() external onlyOwner { address payable _owner = address(uint160(owner())); _owner.transfer(address(this).balance); } // address(this).balance可以返回存储在这个合约中的所有余额 }   只有当一个地址是可支付地址类型时，才能向该地址转移以太币。同时，_owner变量是uint160类型的，因此我们必须显式地将其转换为可支付地址类型。\nsolidity可以多继承 1 2 3  contract SatoshiNakamoto is NickSzabo, HalFinney { // Omg, the secrets of the universe revealed! }   ","date":"2023-06-07T00:00:00Z","permalink":"https://jhrsya.github.io/p/solidity/","title":"solidity"},{"content":"airdrop 什么是token airdrop? Token Airdrop（代币空投）定义：代币空投是加密项目向更广泛的受众分发其代币的一种常见方式。通过向社区发送免费代币，项目希望鼓励采用并激发对其项目的兴趣。代币空投也是项目扩大社区规模的一种方式，因为空投的代币需要存储在钱包中才能接收免费分发。\n这种方法在新代币中特别有效。由于人们需要时间了解新的代币并相信它们具有交易价值，项目可以利用空投来建立用户群体。代币空投的基本理念是为开发者提供早期激励，让他们在平台上执行活动，甚至只是简单地持有他们最初的代币。\n在许多情况下，这些免费代币的空投比它们看起来更有价值，因为它们给投资者提供了尝试的机会。\n代币空投的最突出例子是Steemit代币的赠送活动，该活动始于2016年5月。该项目通过代币赠送活动计划筹集1.5万以太币（当时价值4500万美元），最终筹集到4.5万以太币（超过1亿美元）。\n几乎每个有些空闲时间和一点以太币投资余裕的人都能参与这次赠送活动，因此Steemit代币的使用量呈指数级增长。正如Steemit所展示的那样，开发者也可以利用空投确保他们的新代币能够保持价值。\n换句话说，与其将代币赠送给对区块链技术或整个加密货币了解有限的投资者，我们可以奖励早期采用者，同时确保这些新代币具有强大的价值。\nairdrop安全吗？ 尽管代币空投是分发新币和推广新加密货币的一种常见方式，但与空投相关的风险也存在一些问题。\n一些空投是诈骗，用户可能无法获得承诺的代币。此外，空投也可以用于传播恶意软件或窃取用户信息。为了避免成为空投诈骗的受害者，务必仔细审查空投的条款和条件。\n如果条款模糊不清或要求您分享个人信息，应避免参与该空投。\n此外，确保仔细核对所收到的加密货币是否与您预期接收的一致。检查合法加密货币空投的顶级网站包括Airdrops.io、CoinMarketCap、AirdropKing.io、Airdrop Alert和AirdropsMob。\nairdrop操作 就是做任务，有些任务是一次性的，有些是每天都可以做的。\ntwitter tweet 点赞，转发，回复。 需要1. 点击任务 2. 点击 点赞/转发/回复 3. 点击claim\n","date":"2023-06-06T00:00:00Z","permalink":"https://jhrsya.github.io/p/airdrop/","title":"airdrop"},{"content":"javascript javascript常规操作 打印hello world console.log(\u0026quot;hello world!\u0026quot;)\n定义变量或常量 1 2 3 4 5 6  // 定义变量 var x = 10; let x = 10; // 定义常量 const a = 10;   定义函数 1 2 3 4 5  function functionName(parameter1, parameter2, ...) { // 函数体，包含一系列的语句和逻辑  // 可以使用参数(parameter)和执行代码  return result; // 可选，用于返回函数的结果 }   定义类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class ClassName { constructor(parameter1, parameter2, ...) { // 构造函数，用于初始化对象的属性  } method1(parameter1, parameter2, ...) { // 方法1，用于定义类的行为  } method2(parameter1, parameter2, ...) { // 方法2，用于定义类的行为  } // 更多方法和属性... }   下面是一个简单的定义Person类的实例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Person { constructor(name, age) { this.name = name; this.age = age; } sayHello() { console.log(`Hello, my name is ${this.name}and I\u0026#39;m ${this.age}years old.`); } } // 创建对象实例 const person1 = new Person(\u0026#34;Alice\u0026#34;, 25); const person2 = new Person(\u0026#34;Bob\u0026#34;, 30); // 调用对象的方法 person1.sayHello(); // 输出结果：Hello, my name is Alice and I\u0026#39;m 25 years old. person2.sayHello(); // 输出结果：Hello, my name is Bob and I\u0026#39;m 30 years old.    使用 Node.js 中的 CommonJS 模块系统进行模块导入的语法 1 2 3 4 5 6 7 8 9 10 11  /* 这行代码使用 require 函数从 @netlify/functions 模块中导入一个名为 schedule 的变量。 require 是 Node.js 中用于导入模块的函数。 @netlify/functions 是一个模块的名称或路径，通过这个模块可以访问 schedule 变量。*/ const { schedule } = require(\u0026#34;@netlify/functions\u0026#34;); /*这行代码使用 require 函数从 \u0026#34;ethers\u0026#34; 模块中导入一个名为 ethers 的变量。 通过这个模块可以访问 ethers 变量。 */ const { ethers } = require(\u0026#34;ethers\u0026#34;) /*这行代码使用 require 函数从 \u0026#34;dotenv\u0026#34; 模块中导入，并调用 config 方法。\u0026#34;dotenv\u0026#34; 模块是一个用于加载环境变量的模块。config 方法用于加载项目根目录下的 .env 文件中的环境变量。*/ require(\u0026#34;dotenv\u0026#34;).config()   定义列表 1 2 3  // 列表的表示 const list = [element1, element2, ...];   定义字典 1 2 3 4 5 6 7  // 字典的表示 const dictionary = { key1: value1, key2: value2, // ... };   定义元组 javascript中无内置的元组类型，可以用列表来模拟。 const tuple = [element1, element2, ...];\n","date":"2023-06-06T00:00:00Z","permalink":"https://jhrsya.github.io/p/javascript/","title":"javascript"},{"content":"数据库 查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本低 查询主键索引：B+树中对应着主键索引和对应的数据行，直接可以通过主键索引来获取对应的数据行 查询二级索引：B+树中对应着二级索引和对应的主键索引，要先通过二级索引找到主键索引，然后再通过主键索引找到对应 的数据行，做了两次查找。\n当查询语句的查询条件中没有用到索引时，那么将会进行全表扫描。\n","date":"2023-05-30T00:00:00Z","permalink":"https://jhrsya.github.io/p/database/","title":"数据库"},{"content":"vue 框架 src/views 视图组件，在浏览器中渲染出的页面\nsrc/components views中的组件代码，在这里写\nsrc/router url路由的路径\n","date":"2023-05-27T00:00:00Z","permalink":"https://jhrsya.github.io/p/vue%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/","title":"vue"},{"content":"langchain踩坑 prompt template中的{}是有特殊含义，要使用需用{{}} 控制LLM的输出为json_string格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  from langchain.schema import BaseOutputParser class JsonOutputParser(BaseOutputParser): def parse(self, output: str) -\u0026gt; Any: return json.loads(output) llm = OpenAI(temperature=0.1) prompt = PromptTemplate( input_variables=[\u0026#34;text\u0026#34;], template=template, output_parser=JsonOutputParser(), ) from langchain.chains import LLMChain chain = LLMChain(llm=llm, prompt=prompt) answer = chain.run(text) # 此时LLM输出是json string格式 json_answer = json.loads(answer) # 把json string 转换为json   用于转化的prompt编写最好写成如下格式：{{\\\u0026quot;type\\\u0026quot;: \\\u0026quot;alert|survey\\\u0026quot;, \\\u0026quot;content\\\u0026quot;: {{\\\u0026quot;abstract\\\u0026quot;: \\\u0026quot;\\\u0026quot;, \\\u0026quot;reason\\\u0026quot;: \\\u0026quot;\\\u0026quot;, \\\u0026quot;solution\\\u0026quot;: \\\u0026quot;\\\u0026quot;(always empty)}}}}\n {}号需要用{}括起来，即{{}} 双引号要加转义字符  langchain查看使用的token个数 ","date":"2023-05-25T00:00:00Z","permalink":"https://jhrsya.github.io/p/langchain_dump/","title":"langchain踩坑"},{"content":"prompt engineering prompt构建原则 写清晰又准确的指令 使用分隔符  Triple quotes: \u0026quot;\u0026quot;\u0026quot; Triple backticks: ``` Triple dashes: \u0026mdash; Angle brackets: \u0026lt;\u0026gt; XML tags: \u0026lt;tag\u0026gt; \u0026lt;/tag\u0026gt;  要求用结构化输出 要求模型检查是否满足条件 提供少量成功执行任务的示例 ","date":"2023-05-25T00:00:00Z","permalink":"https://jhrsya.github.io/p/prompt/","title":"吴恩达prompt教程"},{"content":"区块链开发 nft根据名字查看address的api ","date":"2023-05-23T00:00:00Z","permalink":"https://jhrsya.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BC%80%E5%8F%91/","title":"区块链开发"},{"content":"scrapy爬虫 scrapy 操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  安装Scrapy： 使用pip命令安装Scrapy：pip install Scrapy 创建Scrapy项目： 在命令行中使用以下命令创建一个新的Scrapy项目：scrapy startproject project_name 这将在当前目录下创建一个名为project_name的文件夹，其中包含Scrapy项目的基本结构和文件。 定义爬虫： 在Scrapy项目中，您需要定义一个或多个爬虫。进入项目文件夹，然后使用以下命令创建一个新的爬虫：scrapy genspider spider_name domain 这将在spiders文件夹中创建一个名为spider_name的爬虫文件，并指定要爬取的域名。 编写爬虫代码： 打开生成的爬虫文件（位于spiders文件夹中），使用Python编写爬虫逻辑。您需要定义要提取的数据、要爬取的URL、如何处理响应等。 运行爬虫： 使用以下命令在命令行中运行爬虫：scrapy crawl spider_name 这将启动爬虫并开始抓取数据。您可以根据需要在命令行中使用不同的参数来配置爬虫行为。 处理提取的数据： Scrapy提供了数据处理管道（pipeline）的机制，您可以在其中定义对提取的数据进行处理和存储的操作。在项目文件夹中的pipelines.py文件中可以找到和配置数据管道。   做完scrapy genspider spider_name domain操作后需要把settings.py文件中的\n1 2 3  ITEM_PIPELINES = { \u0026#34;paper_crawl.pipelines.PaperCrawlPipeline\u0026#34;: 300, }   的注释去掉\n","date":"2023-05-19T00:00:00Z","permalink":"https://jhrsya.github.io/p/scrapy%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/","title":"scrapy爬虫框架"},{"content":"langchain实战 打印目录中每个文件夹和文件的大小 tools工具类的输入是通过控制SearchInput来实现的\n1 2 3 4 5 6  import os import json with open(\u0026#34;api_key.json\u0026#34;, \u0026#34;r\u0026#34;) as f: api_key = json.load(f) os.environ[\u0026#34;OPENAI_API_KEY\u0026#34;] = api_key[\u0026#34;OPANAI_API_KEY\u0026#34;] os.environ[\u0026#34;SERPAPI_API_KEY\u0026#34;] = api_key[\u0026#34;SERPAPI_API_KEY\u0026#34;]   定义tool工具\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  from langchain.tools.base import tool, BaseModel, Field def get_size(path): total_size = 0 if os.path.isfile(path): total_size += os.path.getsize(path) elif os.path.isdir(path): for dirpath, dirnames, filenames in os.walk(path): for filename in filenames: file_path = os.path.join(dirpath, filename) total_size += os.path.getsize(file_path) return total_size class SearchInput(BaseModel): folder_path: str = Field(description=\u0026#34;should be a path to a folder\u0026#34;) @tool(\u0026#34;folder_size\u0026#34;, return_direct=True, args_schema=SearchInput) def get_file_sizes(folder_path: str): \u0026#34;\u0026#34;\u0026#34;To calculate the sizes of folders within a directory, you can use this tool. The input for this tool must be either a folder path.\u0026#34;\u0026#34;\u0026#34; items_sizes = \u0026#34;\u0026#34; for item in os.listdir(folder_path): item_path = os.path.join(folder_path, item) size = get_size(item_path) items_sizes += f\u0026#34;名称: {item}\\t大小: {size}字节\\n\u0026#34; return items_sizes get_file_sizes   StructuredTool(name='folder_size', description='folder_size(folder_path: str) - To calculate the sizes of folders within a directory, you can use this tool. The input for this tool must be either \u0026quot;.\u0026quot; or \u0026quot;../\u0026quot;.', args_schema=\u0026lt;class '__main__.SearchInput'\u0026gt;, return_direct=True, verbose=False, callbacks=None, callback_manager=None, func=\u0026lt;function get_file_sizes at 0x000001A26448D700\u0026gt;, coroutine=None)  如何把文本输入转化为路径名\n1 2 3 4 5  from langchain.agents import AgentType, initialize_agent from langchain.chat_models import ChatOpenAI llm = ChatOpenAI(temperature=0) agent = initialize_agent([get_file_sizes], llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True) agent.run(\u0026#34;The size of the directory: C:\\\\xili\\\\ApiService.\u0026#34;)   \u001b[1m\u0026gt; Entering new AgentExecutor chain...\u001b[0m \u001b[32;1m\u001b[1;3mI need to use the folder_size tool to calculate the size of the directory. Action: folder_size Action Input: \u0026quot;C:\\xili\\ApiService\u0026quot;\u001b[0m Observation: \u001b[36;1m\u001b[1;3m文件名: .gitignore\t大小: 1987字节 文件名: deploy.sh\t大小: 100字节 文件名: docker-compose.yaml\t大小: 1242字节 文件名: Dockerfile\t大小: 360字节 文件名: LICENSE\t大小: 11357字节 文件名: main.py\t大小: 295字节 文件名: README.md\t大小: 5324字节 文件名: requirements.txt\t大小: 1131字节 文件名: scheduler.py\t大小: 284字节 \u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m '文件名: .gitignore\\t大小: 1987字节\\n文件名: deploy.sh\\t大小: 100字节\\n文件名: docker-compose.yaml\\t大小: 1242字节\\n文件名: Dockerfile\\t大小: 360字节\\n文件名: LICENSE\\t大小: 11357字节\\n文件名: main.py\\t大小: 295字节\\n文件名: README.md\\t大小: 5324字节\\n文件名: requirements.txt\\t大小: 1131字节\\n文件名: scheduler.py\\t大小: 284字节\\n'  1  agent.run(\u0026#34;The size of the parent directory.\u0026#34;)   \u001b[1m\u0026gt; Entering new AgentExecutor chain...\u001b[0m \u001b[32;1m\u001b[1;3mI need to use the folder_size tool to calculate the size of the parent directory. Action: folder_size Action Input: \u0026quot;../\u0026quot;\u001b[0m Observation: \u001b[36;1m\u001b[1;3m文件名: chatgpt.py\t大小: 635字节 文件名: docker-compose.yml\t大小: 949字节 文件名: hello.py\t大小: 168字节 文件名: requirements.txt\t大小: 9861字节 文件名: test_eth.py\t大小: 613字节 文件名: test_fastapi.py\t大小: 2467字节 文件名: test_js.html\t大小: 708字节 文件名: test_middle.py\t大小: 1261字节 文件名: test_peewee.py\t大小: 854字节 文件名: test_postgresql.py\t大小: 3160字节 文件名: test_python.py\t大小: 141字节 文件名: test_vue.html\t大小: 1306字节 文件名: zero.cpp\t大小: 1000字节 文件名: zero.exe\t大小: 71269字节 \u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m '文件名: chatgpt.py\\t大小: 635字节\\n文件名: docker-compose.yml\\t大小: 949字节\\n文件名: hello.py\\t大小: 168字节\\n文件名: requirements.txt\\t大小: 9861字节\\n文件名: test_eth.py\\t大小: 613字节\\n文件名: test_fastapi.py\\t大小: 2467字节\\n文件名: test_js.html\\t大小: 708字节\\n文件名: test_middle.py\\t大小: 1261字节\\n文件名: test_peewee.py\\t大小: 854字节\\n文件名: test_postgresql.py\\t大小: 3160字节\\n文件名: test_python.py\\t大小: 141字节\\n文件名: test_vue.html\\t大小: 1306字节\\n文件名: zero.cpp\\t大小: 1000字节\\n文件名: zero.exe\\t大小: 71269字节\\n'  ","date":"2023-05-16T00:00:00Z","permalink":"https://jhrsya.github.io/p/langchain%E5%AE%9E%E6%88%98/","title":"langchain实战"},{"content":"docker docker概念 Containers 容器（Containers）：容器是基于镜像创建的运行实例。它可以被启动、停止、删除和管理。容器是独立且隔离的运行环境，类似于一个轻量级的虚拟机。容器包含了运行应用程序所需的所有文件和配置，包括基础镜像和额外的可写层。每个容器都是一个独立的进程，拥有自己的文件系统、网络和进程空间。\n容器之间是相互隔离的，每个容器都有自己的文件系统和进程空间，它们可以并行运行，互不干扰。\nImages 镜像（Images）：镜像是一个只读的模板或蓝图，它包含了运行容器所需的文件系统、应用程序代码、依赖库、环境变量以及配置等。可以将镜像看作是一个软件包，用于创建和运行容器。镜像类似于操作系统的镜像文件，但并不是一个操作系统本身，而是一个应用程序或服务的打包。\n容器不等同于操作系统，而是在操作系统上运行的一个或多个应用程序的实例。镜像提供了容器运行所需的环境和文件，类似于一个应用程序的打包，而容器则是镜像的运行实例。\ndocker实操 安装docker\n构建应用 文件名：test_fastapi.py\n1 2 3 4 5 6 7 8 9 10 11 12  import uvicorn from fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/\u0026#34;) async def read_root(): return {\u0026#34;Hello\u0026#34;: \u0026#34;World\u0026#34;} if __name__ == \u0026#39;__main__\u0026#39;: # 注意host必须是0.0.0.0，让所有ip都能访问 uvicorn.run(app=\u0026#39;test_fastapi:app\u0026#39;, host=\u0026#34;0.0.0.0\u0026#34;, port=8000)   requirements.txt内容：\n1 2  fastapi uvicorn   Dockerfile文件 Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。 书写Dockerfile文件如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # FROM python FROM python:3.9-slim-buster # 把当前目录所有文件拷贝到docker的/app目录下 COPY . /app # 切换工作目录为/app WORKDIR /app # 安装构件app所需要的package RUN pip install -r requirements.txt # 执行命令python test_fastapi.py CMD [ \u0026#34;python\u0026#34;, \u0026#34;test_fastapi.py\u0026#34; ]   目前来说目录中有文件为； test_fastapi.py, requirements.txt, Dockfile\n最简单的一个应用搭建好了，现在开始构建images(注意：必须进入应用的目录):\n1  docker build -t test .  -t 等价于\u0026ndash;tag\n运行container:\n1  docker run -d -p 8000:8000 --name test test  -d 表示detached，容器在后台运行，-p 表示端口号，前一个是宿主端口号，后一个是容器端口号，\u0026ndash;name表示需要构建container的名字，最后一个test表示image的名字。\ndocker-compose.yml文件 vscode基于docker开发 以python开发为例，首先建立包含python的开发环境的docker。\nPubkeyAuthentication yes #启用公钥私钥配对认证方式 PermitRootLogin yes #允许root用户使用ssh登录 PasswordAuthentication yes\n","date":"2023-05-12T00:00:00Z","permalink":"https://jhrsya.github.io/p/docker/","title":"docker"},{"content":"langchain agents篇agents Agents Types Agents使用LLM决定做什么action以及以什么顺序做action。一个action要么是使用一个工具观察它的结果，要么是给用户返回一个response。 下面是在Langchain中可以使用的Agents类型：\n zero-shot-react-description  这个agent使用ReAct 框架决定使用哪一种tool，仅仅基于tool\u0026rsquo;s description。这个agent需要给每一个tool写一个description   react-docstore  这个agent使用ReAct框架去和docstore(文档库)交互。必须提供两个Tool: Search 和 Lookup Tool。Search tool 是从文档中搜索，Lookup tool是从最近找到的文件中查找一个术语。paper链接   self-ask-with-search  这个agent只是用一个tool: Intermediate Answer，这个tool可以给问题查找正确的答案。paper链接   conversational-react-description  这个agent专门用于对话，prompt被设计成让agent更容易对话。它使用ReAct框架去决定使用哪一个tool，使用memory去记住之前的对话交互。    1 2 3 4 5 6  import os import json with open(\u0026#34;api_key.json\u0026#34;, \u0026#34;r\u0026#34;) as f: api_key = json.load(f) os.environ[\u0026#34;OPENAI_API_KEY\u0026#34;] = api_key[\u0026#34;OPANAI_API_KEY\u0026#34;] os.environ[\u0026#34;SERPAPI_API_KEY\u0026#34;] = api_key[\u0026#34;SERPAPI_API_KEY\u0026#34;]   Custom Agent 自定义Agent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  from langchain.agents import Tool, AgentExecutor, BaseSingleActionAgent from langchain import OpenAI, SerpAPIWrapper search = SerpAPIWrapper() tools = [ Tool( name = \u0026#34;Search\u0026#34;, func=search.run, description=\u0026#34;useful for when you need to answer questions about current events\u0026#34;, return_direct=True ) ] from typing import List, Tuple, Any, Union from langchain.schema import AgentAction, AgentFinish class FakeAgent(BaseSingleActionAgent): \u0026#34;\u0026#34;\u0026#34;Fake Custom Agent.\u0026#34;\u0026#34;\u0026#34; @property def input_keys(self): return [\u0026#34;input\u0026#34;] def plan( self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any ) -\u0026gt; Union[AgentAction, AgentFinish]: \u0026#34;\u0026#34;\u0026#34;Given input, decided what to do. Args: intermediate_steps: Steps the LLM has taken to date, along with observations **kwargs: User inputs. Returns: Action specifying what tool to use. \u0026#34;\u0026#34;\u0026#34; return AgentAction(tool=\u0026#34;Search\u0026#34;, tool_input=kwargs[\u0026#34;input\u0026#34;], log=\u0026#34;\u0026#34;) async def aplan( self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any ) -\u0026gt; Union[AgentAction, AgentFinish]: \u0026#34;\u0026#34;\u0026#34;Given input, decided what to do. Args: intermediate_steps: Steps the LLM has taken to date, along with observations **kwargs: User inputs. Returns: Action specifying what tool to use. \u0026#34;\u0026#34;\u0026#34; return AgentAction(tool=\u0026#34;Search\u0026#34;, tool_input=kwargs[\u0026#34;input\u0026#34;], log=\u0026#34;\u0026#34;) agent = FakeAgent() agent_executor = AgentExecutor.from_agent_and_tools(agent=agent, tools=tools, verbose=True) agent_executor.run(\u0026#34;How many people live in china as of 2023?\u0026#34;)   \u001b[1m\u0026gt; Entering new AgentExecutor chain...\u001b[0m \u001b[32;1m\u001b[1;3m\u001b[0m\u001b[36;1m\u001b[1;3m1,455,144,001\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m '1,455,144,001'  Custom LLM Agent 自定义LLM agent，一个LLM由三个部分组成：\n PromptTemplate: 用于指导语言模型做什么 LLM stop sequence: 一定这个stop sequence出现，语言模型停止生成 OutputParser: 这个决定了如何解析LLMOutput为一个AgentAction或者AgentFinish对象  LLMAgent被用于AgentExecutor. 这个AgentExecutor可以被认为是一个循环：\n 解析用户的输入和之前的步骤后给Agent(LLMAgent) 如果Agent返回AgentFinish，直接返回给用户 如果Agent返回AgentAction，使用这个去调用一个tool，获得一个Observation对象 重复，把AgentAction和Observation传给Agent直到AgentFinish出现为止。  AgentAction是一个由action和action_input组成的response。action指定使用哪一个tool，action_input指定这个tool的输入。log可以提供更多内容(比如logging, tracing, etc)\nAgentFinish是包含了最终发送给用户的消息，用于终止agent的运行。\n1 2 3 4 5 6 7 8  # Set up environment from langchain.agents import Tool, AgentExecutor, LLMSingleActionAgent, AgentOutputParser from langchain.prompts import StringPromptTemplate from langchain import OpenAI, SerpAPIWrapper, LLMChain from typing import List, Union from langchain.schema import AgentAction, AgentFinish import re   Set up tool 1 2 3 4 5 6 7 8 9  # Define which tools the agent can use to answer user queries search = SerpAPIWrapper() tools = [ Tool( name = \u0026#34;Search\u0026#34;, func=search.run, description=\u0026#34;useful for when you need to answer questions about current events\u0026#34; ) ]   Prompt Template 它指定了agent做什么。通常这个模板需要包含：\n tool: agent需要使用的tool和什么时候调用它们 intermediate_steps: 是一个(AgentAction, Observation)元组。它们通常不会直接传给模型，prompt template会以一种特别的方式格式化它们 input: 通用的用户输入  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  # Set up the base template template = \u0026#34;\u0026#34;\u0026#34;Answer the following questions as best you can, but speaking as a pirate might speak. You have access to the following tools: {tools}Use the following format: Question: the input question you must answer Thought: you should always think about what to do Action: the action to take, should be one of [{tool_names}] Action Input: the input to the action Observation: the result of the action ... (this Thought/Action/Action Input/Observation can repeat N times) Thought: I now know the final answer Final Answer: the final answer to the original input question Begin! Remember to speak as a pirate when giving your final answer. Use lots of \u0026#34;Arg\u0026#34;s Question: {input}{agent_scratchpad}\u0026#34;\u0026#34;\u0026#34;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # Set up a prompt template class CustomPromptTemplate(StringPromptTemplate): # The template to use template: str # The list of tools available tools: List[Tool] def format(self, **kwargs) -\u0026gt; str: # Get the intermediate steps (AgentAction, Observation tuples) # Format them in a particular way intermediate_steps = kwargs.pop(\u0026#34;intermediate_steps\u0026#34;) thoughts = \u0026#34;\u0026#34; for action, observation in intermediate_steps: thoughts += action.log thoughts += f\u0026#34;\\nObservation: {observation}\\nThought: \u0026#34; # Set the agent_scratchpad variable to that value kwargs[\u0026#34;agent_scratchpad\u0026#34;] = thoughts # Create a tools variable from the list of tools provided kwargs[\u0026#34;tools\u0026#34;] = \u0026#34;\\n\u0026#34;.join([f\u0026#34;{tool.name}: {tool.description}\u0026#34; for tool in self.tools]) # Create a list of tool names for the tools provided kwargs[\u0026#34;tool_names\u0026#34;] = \u0026#34;, \u0026#34;.join([tool.name for tool in self.tools]) return self.template.format(**kwargs) prompt = CustomPromptTemplate( template=template, tools=tools, # This omits the `agent_scratchpad`, `tools`, and `tool_names` variables because those are generated dynamically # This includes the `intermediate_steps` variable because that is needed input_variables=[\u0026#34;input\u0026#34;, \u0026#34;intermediate_steps\u0026#34;] )   Output Parser 用于把LLM output解析成AgentAction和AgentFinish。这个通常取决于prompt的使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class CustomOutputParser(AgentOutputParser): def parse(self, llm_output: str) -\u0026gt; Union[AgentAction, AgentFinish]: # Check if agent should finish if \u0026#34;Final Answer:\u0026#34; in llm_output: return AgentFinish( # Return values is generally always a dictionary with a single `output` key # It is not recommended to try anything else at the moment :) return_values={\u0026#34;output\u0026#34;: llm_output.split(\u0026#34;Final Answer:\u0026#34;)[-1].strip()}, log=llm_output, ) # Parse out the action and action input regex = r\u0026#34;Action\\s*\\d*\\s*:(.*?)\\nAction\\s*\\d*\\s*Input\\s*\\d*\\s*:[\\s]*(.*)\u0026#34; match = re.search(regex, llm_output, re.DOTALL) if not match: raise ValueError(f\u0026#34;Could not parse LLM output: `{llm_output}`\u0026#34;) action = match.group(1).strip() action_input = match.group(2) # Return the action and action input return AgentAction(tool=action, tool_input=action_input.strip(\u0026#34; \u0026#34;).strip(\u0026#39;\u0026#34;\u0026#39;), log=llm_output) output_parser = CustomOutputParser()   Set up LLM 1  llm = OpenAI(temperature=0)   Define the stop sequence 告诉LLM什么时候停止生成。这个标志很大的取决于prompt和model。\nSet up the Agent 1 2 3 4 5 6 7 8 9  # LLM chain consisting of the LLM and a prompt llm_chain = LLMChain(llm=llm, prompt=prompt) tool_names = [tool.name for tool in tools] agent = LLMSingleActionAgent( llm_chain=llm_chain, output_parser=output_parser, stop=[\u0026#34;\\nObservation:\u0026#34;], allowed_tools=tool_names )   Use the Agent 1 2  agent_executor = AgentExecutor.from_agent_and_tools(agent=agent, tools=tools, verbose=True) agent_executor.run(\u0026#34;How many people live in china as of 2023?\u0026#34;)   \u001b[1m\u0026gt; Entering new AgentExecutor chain...\u001b[0m \u001b[32;1m\u001b[1;3mThought: I need to find out the population of China in 2023 Action: Search Action Input: Population of China in 2023\u001b[0m Observation:\u001b[36;1m\u001b[1;3mThe current population of China is 1,455,144,001 as of Thursday, May 11, 2023, based on Worldometer elaboration of the latest United Nations data.\u001b[0m \u001b[32;1m\u001b[1;3m I now know the final answer Final Answer: Arg, there be 1,455,144,001 people livin' in China as of 2023!\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m \u0026quot;Arg, there be 1,455,144,001 people livin' in China as of 2023!\u0026quot;  Adding Memory 给agent添加记忆，需要做两步：\n 给自定义的promot添加chat_history 给agent executor添加一个memory对象  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  # Set up the base template template_with_history = \u0026#34;\u0026#34;\u0026#34;Answer the following questions as best you can, but speaking as a pirate might speak. You have access to the following tools: {tools}Use the following format: Question: the input question you must answer Thought: you should always think about what to do Action: the action to take, should be one of [{tool_names}] Action Input: the input to the action Observation: the result of the action ... (this Thought/Action/Action Input/Observation can repeat N times) Thought: I now know the final answer Final Answer: the final answer to the original input question Begin! Remember to speak as a pirate when giving your final answer. Use lots of \u0026#34;Arg\u0026#34;s Previous conversation history: {history}New question: {input}{agent_scratchpad}\u0026#34;\u0026#34;\u0026#34; prompt_with_history = CustomPromptTemplate( template=template_with_history, tools=tools, # This omits the `agent_scratchpad`, `tools`, and `tool_names` variables because those are generated dynamically # This includes the `intermediate_steps` variable because that is needed input_variables=[\u0026#34;input\u0026#34;, \u0026#34;intermediate_steps\u0026#34;, \u0026#34;history\u0026#34;] ) llm_chain = LLMChain(llm=llm, prompt=prompt_with_history) tool_names = [tool.name for tool in tools] agent = LLMSingleActionAgent( llm_chain=llm_chain, output_parser=output_parser, stop=[\u0026#34;\\nObservation:\u0026#34;], allowed_tools=tool_names ) from langchain.memory import ConversationBufferWindowMemory memory=ConversationBufferWindowMemory(k=2) agent_executor = AgentExecutor.from_agent_and_tools(agent=agent, tools=tools, verbose=True, memory=memory) agent_executor.run(\u0026#34;How many people live in china as of 2023?\u0026#34;)   \u001b[1m\u0026gt; Entering new AgentExecutor chain...\u001b[0m \u001b[32;1m\u001b[1;3mThought: I need to find out the population of China in 2023 Action: Search Action Input: Population of China in 2023\u001b[0m Observation:\u001b[36;1m\u001b[1;3mThe current population of China is 1,455,144,001 as of Thursday, May 11, 2023, based on Worldometer elaboration of the latest United Nations data.\u001b[0m \u001b[32;1m\u001b[1;3m I now know the final answer Final Answer: Arrr, there be 1,455,144,001 people livin' in China as of 2023!\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m \u0026quot;Arrr, there be 1,455,144,001 people livin' in China as of 2023!\u0026quot;  1  agent_executor.run(\u0026#34;how about in india?\u0026#34;)   \u001b[1m\u0026gt; Entering new AgentExecutor chain...\u001b[0m \u001b[32;1m\u001b[1;3mThought: I need to find out how many people live in India. Action: Search Action Input: How many people live in India as of 2023\u001b[0m Observation:\u001b[36;1m\u001b[1;3m24 April 2023 - China will soon cede its long-held status as the world's most populous country. By the end of this month, India's population is expected to reach 1,425,775,850 people, matching and then surpassing the population of mainland China.\u001b[0m \u001b[32;1m\u001b[1;3m I now know the final answer. Final Answer: Arg, there be 1,425,775,850 people livin' in India as of 2023!\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m \u0026quot;Arg, there be 1,425,775,850 people livin' in India as of 2023!\u0026quot;  ","date":"2023-05-12T00:00:00Z","permalink":"https://jhrsya.github.io/p/langchain-agent-agent/","title":"langchain"},{"content":"langchain agent篇 定义自己的tools 1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 导入通用的包 # Import things that are needed generically from langchain import LLMMathChain, SerpAPIWrapper from langchain.agents import AgentType, initialize_agent from langchain.chat_models import ChatOpenAI from langchain.tools import BaseTool, StructuredTool, Tool, tool import os import json with open(\u0026#34;api_key.json\u0026#34;, \u0026#34;r\u0026#34;) as f: api_key = json.load(f) os.environ[\u0026#34;OPENAI_API_KEY\u0026#34;] = api_key[\u0026#34;OPANAI_API_KEY\u0026#34;] os.environ[\u0026#34;SERPAPI_API_KEY\u0026#34;] = api_key[\u0026#34;SERPAPI_API_KEY\u0026#34;] llm = ChatOpenAI(temperature=0)   Completely New Tools-String input and output 最简单的tools, 输入时字符串，输出也是字符串\nTool dataclass 1 2 3 4 5 6 7 8 9 10 11  # Load the tool configs that are needed. search = SerpAPIWrapper() llm_math_chain = LLMMathChain(llm=llm, verbose=True) tools = [ Tool.from_function( func=search.run, name = \u0026#34;Search\u0026#34;, description=\u0026#34;useful for when you need to answer questions about current events\u0026#34; # coroutine= ... \u0026lt;- you can specify an async method if desired as well ), ]   也可以通过定义args_schema参数来为输入提供更多的信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  from pydantic import BaseModel, Field class CalculatorInput(BaseModel): question: str = Field() tools.append( Tool.from_function( func=llm_math_chain.run, name=\u0026#34;Calculator\u0026#34;, description=\u0026#34;useful for when you need to answer questions about math\u0026#34;, args_schema=CalculatorInput # coroutine= ... \u0026lt;- you can specify an async method if desired as well ) ) # Construct the agent. We will use the default agent type here. # See documentation for a full list of options. agent = initialize_agent(tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True) agent.run(\u0026#34;What is the height of the tallest mountain in the world? What is the result when its height is raised to the power of 0.23?\u0026#34;)   \u001b[1m\u0026gt; Entering new AgentExecutor chain...\u001b[0m \u001b[32;1m\u001b[1;3mI need to find the height of the tallest mountain in the world and then raise it to the power of 0.23. Action: Search Action Input: \u0026quot;height of tallest mountain in the world\u0026quot;\u001b[0m Observation: \u001b[36;1m\u001b[1;3mMount Everest\u001b[0m Thought:\u001b[32;1m\u001b[1;3mNow I need to find the height of Mount Everest. Action: Search Action Input: \u0026quot;height of Mount Everest\u0026quot;\u001b[0m Observation: \u001b[36;1m\u001b[1;3m29,032′\u001b[0m Thought:\u001b[32;1m\u001b[1;3mNow I need to raise the height of Mount Everest to the power of 0.23. Action: Calculator Action Input: 29032^0.23\u001b[0m \u001b[1m\u0026gt; Entering new LLMMathChain chain...\u001b[0m 29032^0.23\u001b[32;1m\u001b[1;3m```text 29032 ** 0.23 ``` ...numexpr.evaluate(\u0026quot;29032 ** 0.23\u0026quot;)... \u001b[0m Answer: \u001b[33;1m\u001b[1;3m10.628248489241304\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m Observation: \u001b[31;1m\u001b[1;3mAnswer: 10.628248489241304\u001b[0m Thought:\u001b[32;1m\u001b[1;3mI now know the final answer. Final Answer: The result when the height of the tallest mountain in the world (Mount Everest) is raised to the power of 0.23 is approximately 10.63.\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m 'The result when the height of the tallest mountain in the world (Mount Everest) is raised to the power of 0.23 is approximately 10.63.'  Subclassing the BaseTool class 继承BaseTool类，可以实现更多的控制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  from typing import Optional, Type from langchain.callbacks.manager import AsyncCallbackManagerForToolRun, CallbackManagerForToolRun class CustomSearchTool(BaseTool): name = \u0026#34;custom_search\u0026#34; description = \u0026#34;useful for when you need to answer questions about current events\u0026#34; def _run(self, query: str, run_manager: Optional[CallbackManagerForToolRun] = None) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Use the tool.\u0026#34;\u0026#34;\u0026#34; return search.run(query) async def _arun(self, query: str, run_manager: Optional[AsyncCallbackManagerForToolRun] = None) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Use the tool asynchronously.\u0026#34;\u0026#34;\u0026#34; raise NotImplementedError(\u0026#34;custom_search does not support async\u0026#34;) class CustomCalculatorTool(BaseTool): name = \u0026#34;Calculator\u0026#34; description = \u0026#34;useful for when you need to answer questions about math\u0026#34; args_schema: Type[BaseModel] = CalculatorInput def _run(self, query: str, run_manager: Optional[CallbackManagerForToolRun] = None) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Use the tool.\u0026#34;\u0026#34;\u0026#34; return llm_math_chain.run(query) async def _arun(self, query: str, run_manager: Optional[AsyncCallbackManagerForToolRun] = None) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Use the tool asynchronously.\u0026#34;\u0026#34;\u0026#34; raise NotImplementedError(\u0026#34;Calculator does not support async\u0026#34;) tools = [CustomSearchTool(), CustomCalculatorTool()] agent = initialize_agent(tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True) agent.run(\u0026#34;How tall is the tallest person in the world? Please provide the height in meters. What is the result when their height is raised to the power of 0.34?\u0026#34;)   \u001b[1m\u0026gt; Entering new AgentExecutor chain...\u001b[0m \u001b[32;1m\u001b[1;3mI need to find the height of the tallest person in the world and then raise it to the power of 0.34. Action: custom_search Action Input: \u0026quot;Height of tallest person in the world\u0026quot; \u001b[0m Observation: \u001b[36;1m\u001b[1;3mRobert Wadlow\u001b[0m Thought:\u001b[32;1m\u001b[1;3mI need to search for Robert Wadlow's height Action: custom_search Action Input: \u0026quot;Robert Wadlow height\u0026quot; \u001b[0m Observation: \u001b[36;1m\u001b[1;3m8′ 11″\u001b[0m Thought:\u001b[32;1m\u001b[1;3mI need to convert 8′ 11″ to meters Action: Calculator Action Input: 8*0.3048 + 11*0.0254 \u001b[0m \u001b[1m\u0026gt; Entering new LLMMathChain chain...\u001b[0m 8*0.3048 + 11*0.0254\u001b[32;1m\u001b[1;3m```text 8*0.3048 + 11*0.0254 ``` ...numexpr.evaluate(\u0026quot;8*0.3048 + 11*0.0254\u0026quot;)... \u001b[0m Answer: \u001b[33;1m\u001b[1;3m2.7178\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m Observation: \u001b[33;1m\u001b[1;3mAnswer: 2.7178\u001b[0m Thought:\u001b[32;1m\u001b[1;3mNow I need to raise 2.7178 to the power of 0.34 Action: Calculator Action Input: 2.7178^0.34 \u001b[0m \u001b[1m\u0026gt; Entering new LLMMathChain chain...\u001b[0m 2.7178^0.34\u001b[32;1m\u001b[1;3m```text 2.7178**0.34 ``` ...numexpr.evaluate(\u0026quot;2.7178**0.34\u0026quot;)... \u001b[0m Answer: \u001b[33;1m\u001b[1;3m1.4048629141584312\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m Observation: \u001b[33;1m\u001b[1;3mAnswer: 1.4048629141584312\u001b[0m Thought:\u001b[32;1m\u001b[1;3mI now know the final answer Final Answer: The tallest person in the world was Robert Wadlow, who was 2.7178 meters tall. When his height is raised to the power of 0.34, the result is approximately 1.4049.\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m 'The tallest person in the world was Robert Wadlow, who was 2.7178 meters tall. When his height is raised to the power of 0.34, the result is approximately 1.4049.'  Using the tool decorator 使用@tool装饰器可以通过函数定义Tool\n1 2 3 4 5 6 7 8  from langchain.tools import tool @tool def search_api(query: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Searches the API for the query.\u0026#34;\u0026#34;\u0026#34; return f\u0026#34;Results for query {query}\u0026#34; search_api   StructuredTool(name='search_api', description='search_api(query: str) -\u0026gt; str - Searches the API for the query.', args_schema=\u0026lt;class 'pydantic.main.search_apiSchemaSchema'\u0026gt;, return_direct=False, verbose=False, callbacks=None, callback_manager=None, func=\u0026lt;function search_api at 0x0000012A821A5C10\u0026gt;, coroutine=None)  也可以设置tool name 和是否直接返回\n1 2 3 4 5  @tool(\u0026#34;search\u0026#34;, return_direct=True) def search_api(query: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Searches the API for the query.\u0026#34;\u0026#34;\u0026#34; return \u0026#34;Results\u0026#34; search_api   StructuredTool(name='search', description='search(query: str) -\u0026gt; str - Searches the API for the query.', args_schema=\u0026lt;class 'pydantic.main.searchSchemaSchema'\u0026gt;, return_direct=True, verbose=False, callbacks=None, callback_manager=None, func=\u0026lt;function search_api at 0x0000012AFC399820\u0026gt;, coroutine=None)  也可以设置args_schema参数给输入提供更多的信息\n1 2 3 4 5 6 7 8  class SearchInput(BaseModel): query: str = Field(description=\u0026#34;should be a search query\u0026#34;) @tool(\u0026#34;search\u0026#34;, return_direct=True, args_schema=SearchInput) def search_api(query: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Searches the API for the query.\u0026#34;\u0026#34;\u0026#34; return \u0026#34;Results\u0026#34; search_api   StructuredTool(name='search', description='search(query: str) -\u0026gt; str - Searches the API for the query.', args_schema=\u0026lt;class '__main__.SearchInput'\u0026gt;, return_direct=True, verbose=False, callbacks=None, callback_manager=None, func=\u0026lt;function search_api at 0x0000012A81C93E50\u0026gt;, coroutine=None)  Custom Structured Tools 如果函数需要结构化的参数，可以使用直接StructuredTool类，或者继承BaseTool类\nStructuredTool dataclass 可以使用StructuredTool.from_function()函数把一个函数快速的转换为一个StructruedTool类\n1 2 3 4 5 6 7 8 9 10  import requests from langchain.tools import StructuredTool def post_message(url: str, body: dict, parameters: Optional[dict] = None) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Sends a POST request to the given url with the given body and parameters.\u0026#34;\u0026#34;\u0026#34; result = requests.post(url, json=body, params=parameters) return f\u0026#34;Status: {result.status_code}- {result.text}\u0026#34; tool = StructuredTool.from_function(post_message) tool   StructuredTool(name='post_message', description='post_message(url: str, body: dict, parameters: Optional[dict] = None) -\u0026gt; str - Sends a POST request to the given url with the given body and parameters.', args_schema=\u0026lt;class 'pydantic.main.post_messageSchemaSchema'\u0026gt;, return_direct=False, verbose=False, callbacks=None, callback_manager=None, func=\u0026lt;function post_message at 0x0000012A821A5040\u0026gt;, coroutine=None)  Subclassing the BaseTool 实现_run方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  from typing import Optional, Type from langchain.callbacks.manager import AsyncCallbackManagerForToolRun, CallbackManagerForToolRun class CustomSearchTool(BaseTool): name = \u0026#34;custom_search\u0026#34; description = \u0026#34;useful for when you need to answer questions about current events\u0026#34; def _run(self, query: str, engine: str = \u0026#34;google\u0026#34;, gl: str = \u0026#34;us\u0026#34;, hl: str = \u0026#34;en\u0026#34;, run_manager: Optional[CallbackManagerForToolRun] = None) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Use the tool.\u0026#34;\u0026#34;\u0026#34; search_wrapper = SerpAPIWrapper(params={\u0026#34;engine\u0026#34;: engine, \u0026#34;gl\u0026#34;: gl, \u0026#34;hl\u0026#34;: hl}) return search_wrapper.run(query) async def _arun(self, query: str, engine: str = \u0026#34;google\u0026#34;, gl: str = \u0026#34;us\u0026#34;, hl: str = \u0026#34;en\u0026#34;, run_manager: Optional[AsyncCallbackManagerForToolRun] = None) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Use the tool asynchronously.\u0026#34;\u0026#34;\u0026#34; raise NotImplementedError(\u0026#34;custom_search does not support async\u0026#34;) # You can provide a custom args schema to add descriptions or custom validation class SearchSchema(BaseModel): query: str = Field(description=\u0026#34;should be a search query\u0026#34;) engine: str = Field(description=\u0026#34;should be a search engine\u0026#34;) gl: str = Field(description=\u0026#34;should be a country code\u0026#34;) hl: str = Field(description=\u0026#34;should be a language code\u0026#34;) class CustomSearchTool(BaseTool): name = \u0026#34;custom_search\u0026#34; description = \u0026#34;useful for when you need to answer questions about current events\u0026#34; args_schema: Type[SearchSchema] = SearchSchema def _run(self, query: str, engine: str = \u0026#34;google\u0026#34;, gl: str = \u0026#34;us\u0026#34;, hl: str = \u0026#34;en\u0026#34;, run_manager: Optional[CallbackManagerForToolRun] = None) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Use the tool.\u0026#34;\u0026#34;\u0026#34; search_wrapper = SerpAPIWrapper(params={\u0026#34;engine\u0026#34;: engine, \u0026#34;gl\u0026#34;: gl, \u0026#34;hl\u0026#34;: hl}) return search_wrapper.run(query) async def _arun(self, query: str, engine: str = \u0026#34;google\u0026#34;, gl: str = \u0026#34;us\u0026#34;, hl: str = \u0026#34;en\u0026#34;, run_manager: Optional[AsyncCallbackManagerForToolRun] = None) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Use the tool asynchronously.\u0026#34;\u0026#34;\u0026#34; raise NotImplementedError(\u0026#34;custom_search does not support async\u0026#34;)   Modify existing tools 修改存在的tools类\n1 2 3 4 5  from langchain.agents import load_tools tools = load_tools([\u0026#34;serpapi\u0026#34;, \u0026#34;llm-math\u0026#34;], llm=llm) tools[0].name = \u0026#34;Google Search\u0026#34; agent = initialize_agent(tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True) agent.run(\u0026#34;Who is Leo DiCaprio\u0026#39;s girlfriend? What is her current age raised to the 0.43 power?\u0026#34;)   \u001b[1m\u0026gt; Entering new AgentExecutor chain...\u001b[0m \u001b[32;1m\u001b[1;3mI need to find out Leo DiCaprio's girlfriend's name and her age. Action: Google Search Action Input: \u0026quot;Leo DiCaprio girlfriend\u0026quot;\u001b[0m Observation: \u001b[36;1m\u001b[1;3mHe went on to date Gisele Bündchen, Bar Refaeli, Blake Lively, Toni Garrn and Nina Agdal, among others, before finally settling down with current girlfriend Camila Morrone, who is 23 years his junior.\u001b[0m Thought:\u001b[32;1m\u001b[1;3mI now know Leo DiCaprio's girlfriend's name and age difference. Action: Calculator Action Input: 23 ^ 0.43\u001b[0m Observation: \u001b[33;1m\u001b[1;3mAnswer: 3.8507291225496925\u001b[0m Thought:\u001b[32;1m\u001b[1;3mI now know the answer to the original question. Final Answer: 3.8507291225496925\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m '3.8507291225496925'  Defining the priorities among Tools 当有几个同类型的Tools时，可以定义Tools的使用优先级\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  # Import things that are needed generically from langchain.agents import initialize_agent, Tool from langchain.agents import AgentType from langchain.llms import OpenAI from langchain import LLMMathChain, SerpAPIWrapper search = SerpAPIWrapper() tools = [ Tool( name = \u0026#34;Search\u0026#34;, func=search.run, description=\u0026#34;useful for when you need to answer questions about current events\u0026#34; ), Tool( name=\u0026#34;Music Search\u0026#34;, # 这是回答的答案，实际上你可以自定义自己的音乐搜索引擎 func=lambda x: \u0026#34;\u0026#39;All I Want For Christmas Is You\u0026#39; by Mariah Carey.\u0026#34;, #Mock Function # 通过加入这段描述来实现这个Tool类的优先级 description=\u0026#34;A Music search engine. Use this more than the normal search if the question is about Music, like \u0026#39;who is the singer of yesterday?\u0026#39; or \u0026#39;what is the most popular song in 2022?\u0026#39;\u0026#34;, ) ] agent = initialize_agent(tools, OpenAI(temperature=0), agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True) agent.run(\u0026#34;what is the most famous song of christmas\u0026#34;)   \u001b[1m\u0026gt; Entering new AgentExecutor chain...\u001b[0m \u001b[32;1m\u001b[1;3m I should use a music search engine to find the answer Action: Music Search Action Input: most famous song of christmas\u001b[0m Observation: \u001b[33;1m\u001b[1;3m'All I Want For Christmas Is You' by Mariah Carey.\u001b[0m Thought:\u001b[32;1m\u001b[1;3m I now know the final answer Final Answer: 'All I Want For Christmas Is You' by Mariah Carey.\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m \u0026quot;'All I Want For Christmas Is You' by Mariah Carey.\u0026quot;  Multi-Input Tools 定义多个输入Tools\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  import os os.environ[\u0026#34;LANGCHAIN_TRACING\u0026#34;] = \u0026#34;true\u0026#34; from langchain import OpenAI from langchain.agents import initialize_agent, AgentType llm = OpenAI(temperature=0) from langchain.tools import StructuredTool def multiplier(a: float, b: float) -\u0026gt; float: \u0026#34;\u0026#34;\u0026#34;Multiply the provided floats.\u0026#34;\u0026#34;\u0026#34; return a * b tool = StructuredTool.from_function(multiplier) # Structured tools are compatible with the STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION agent type.  agent_executor = initialize_agent([tool], llm, agent=AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION, verbose=True) agent_executor.run(\u0026#34;What is 11 times 12\u0026#34;)   WARNING:root:Failed to load default session, using empty session: ('Connection aborted.', ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)) \u001b[1m\u0026gt; Entering new AgentExecutor chain...\u001b[0m \u001b[32;1m\u001b[1;3mAction: ``` { \u0026quot;action\u0026quot;: \u0026quot;multiplier\u0026quot;, \u0026quot;action_input\u0026quot;: {\u0026quot;a\u0026quot;: 11, \u0026quot;b\u0026quot;: 12} } ``` \u001b[0m Observation: \u001b[36;1m\u001b[1;3m132.0\u001b[0m Thought:\u001b[32;1m\u001b[1;3m I know what to respond Action: ``` { \u0026quot;action\u0026quot;: \u0026quot;Final Answer\u0026quot;, \u0026quot;action_input\u0026quot;: \u0026quot;11 times 12 is 132.0\u0026quot; } ```\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m WARNING:root:Failed to persist run: ('Connection aborted.', ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)) '11 times 12 is 132.0'  Multi-Input Tools with a string format 当输入的文本不确定时，可以让llm转换成相对应的文本格式输出，然后自己定义函数解析出想要的数字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  from langchain.llms import OpenAI from langchain.agents import initialize_agent, Tool from langchain.agents import AgentType def multiplier(a, b): return a * b def parsing_multiplier(string): a, b = string.split(\u0026#34;,\u0026#34;) return multiplier(int(a), int(b)) llm = OpenAI(temperature=0) tools = [ Tool( name = \u0026#34;Multiplier\u0026#34;, func=parsing_multiplier, # 这里让输入变成了用逗号隔开的两个数字 description=\u0026#34;useful for when you need to multiply two numbers together. The input to this tool should be a comma separated list of numbers of length two, representing the two numbers you want to multiply together. For example, `1,2` would be the input if you wanted to multiply 1 by 2.\u0026#34; ) ] mrkl = initialize_agent(tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True) mrkl.run(\u0026#34;What is 31 times 43\u0026#34;)   WARNING:root:Failed to load default session, using empty session: ('Connection aborted.', ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)) \u001b[1m\u0026gt; Entering new AgentExecutor chain...\u001b[0m \u001b[32;1m\u001b[1;3m I need to multiply two numbers Action: Multiplier Action Input: 31,43\u001b[0m Observation: \u001b[36;1m\u001b[1;3m1333\u001b[0m Thought:\u001b[32;1m\u001b[1;3m I now know the final answer Final Answer: 31 times 43 is 1333.\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m WARNING:root:Failed to persist run: ('Connection aborted.', ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)) '31 times 43 is 1333.'  Tool Input Schema 设置输出格式验证，可以验证输入的话是否有效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  from typing import Any, Dict from langchain.agents import AgentType, initialize_agent from langchain.llms import OpenAI from langchain.tools.requests.tool import RequestsGetTool, TextRequestsWrapper from pydantic import BaseModel, Field, root_validator llm = OpenAI(temperature=0) import tldextract # 允许出现的域名 _APPROVED_DOMAINS = { \u0026#34;langchain\u0026#34;, \u0026#34;wikipedia\u0026#34;, } class ToolInputSchema(BaseModel): url: str = Field(...) @root_validator def validate_query(cls, values: Dict[str, Any]) -\u0026gt; Dict: url = values[\u0026#34;url\u0026#34;] domain = tldextract.extract(url).domain if domain not in _APPROVED_DOMAINS: raise ValueError(f\u0026#34;Domain {domain}is not on the approved list:\u0026#34; f\u0026#34; {sorted(_APPROVED_DOMAINS)}\u0026#34;) return values tool = RequestsGetTool(args_schema=ToolInputSchema, requests_wrapper=TextRequestsWrapper()) agent = initialize_agent([tool], llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=False) # This will succeed, since there aren\u0026#39;t any arguments that will be triggered during validation answer = agent.run(\u0026#34;What\u0026#39;s the main title on langchain.com?\u0026#34;) # langchain域名允许出现，这里是有效的 print(answer)   WARNING:root:Failed to load default session, using empty session: ('Connection aborted.', ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)) WARNING:root:Failed to persist run: ('Connection aborted.', ConnectionResetError(10054, '远程主机强迫关闭了一个现有的连接。', None, 10054, None)) The main title on langchain.com is \u0026quot;LANG CHAIN 🦜️🔗 Official Home Page\u0026quot;.  1 2  # 这里的域名不允许出现，所以这里是无效的，会有bug agent.run(\u0026#34;What\u0026#39;s the main title on google.com?\u0026#34;)   ","date":"2023-05-11T00:00:00Z","permalink":"https://jhrsya.github.io/p/langchain-agent-tools/","title":"langchain"},{"content":"从语言模型中预测 1 2 3 4 5 6 7 8 9  from langchain.llms import OpenAI import json with open(\u0026#34;api_key.json\u0026#34;, \u0026#34;r\u0026#34;) as f: api_key = json.load(f) import os os.environ[\u0026#34;OPENAI_API_KEY\u0026#34;] = api_key[\u0026#34;OPANAI_API_KEY\u0026#34;] llm = OpenAI(temperature=0.9) text = \u0026#34;What would be a good company name for a company that makes colorful socks?\u0026#34; print(llm(text))   Rainbow Socks Co.  prompt模板：给LLM提供模板 1 2 3 4 5 6 7 8  from langchain.prompts import PromptTemplate prompt = PromptTemplate( input_variables=[\u0026#34;product\u0026#34;], template=\u0026#34;What is a good name for a company that makes {product}?\u0026#34;, ) # 查看模板长什么样子 print(prompt.format(product=\u0026#34;colorful socks\u0026#34;))   What is a good name for a company that makes colorful socks?  把LLMs和prompts结合进多个工作流中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from langchain.prompts import PromptTemplate from langchain.llms import OpenAI llm = OpenAI(temperature=0.9) prompt = PromptTemplate( input_variables=[\u0026#34;product\u0026#34;], template=\u0026#34;What is a good name for a company that makes {product}?\u0026#34;, ) # 导入链，设置prompt和LLM from langchain.chains import LLMChain chain = LLMChain(llm=llm, prompt=prompt) # 使用这个链 chain.run(\u0026#34;colorful socks\u0026#34;)   '\\n\\nColorful Toes.'  Agents：基于用户的输入动态的调用chain 迄今为止，我们所看到的链是按照预定顺序进行。 Agents 不这么做：他们使用LLM来确定要采取的行动及其顺序。一个行动可以是使用工具并观察其输出，或者返回给用户。\n使用Agent需要知道的三个概念：\n Tool: 类似一个函数，给一个输入，有一个输出，比如谷歌搜索。已有的Tool链接 LLM Agent: agent使用的类  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # 下面以谷歌搜索为Tool举例 # ! pip install google-search-results from langchain.agents import load_tools from langchain.agents import initialize_agent from langchain.agents import AgentType from langchain.llms import OpenAI import json import os with open(\u0026#34;api_key.json\u0026#34;, \u0026#34;r\u0026#34;) as f: api_key = json.load(f) os.environ[\u0026#34;SERPAPI_API_KEY\u0026#34;] = api_key[\u0026#34;SERPAPI_API_KEY\u0026#34;] # First, let\u0026#39;s load the language model we\u0026#39;re going to use to control the agent. llm = OpenAI(temperature=0) # Next, let\u0026#39;s load some tools to use. Note that the `llm-math` tool uses an LLM, so we need to pass that in. tools = load_tools([\u0026#34;serpapi\u0026#34;, \u0026#34;llm-math\u0026#34;], llm=llm) # Finally, let\u0026#39;s initialize an agent with the tools, the language model, and the type of agent we want to use. agent = initialize_agent(tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True) # Now let\u0026#39;s test it out! agent.run(\u0026#34;How old is Jay Chou now? What is the square of his age?\u0026#34;)   \u001b[1m\u0026gt; Entering new AgentExecutor chain...\u001b[0m \u001b[32;1m\u001b[1;3m I need to find out Jay Chou's age and then use a calculator to find the square of his age. Action: Search Action Input: \u0026quot;Jay Chou age\u0026quot;\u001b[0m Observation: \u001b[36;1m\u001b[1;3m44 years\u001b[0m Thought:\u001b[32;1m\u001b[1;3m I now need to use a calculator to find the square of 44 Action: Calculator Action Input: 44^2\u001b[0m Observation: \u001b[33;1m\u001b[1;3mAnswer: 1936\u001b[0m Thought:\u001b[32;1m\u001b[1;3m I now know the final answer Final Answer: Jay Chou is 44 years old and the square of his age is 1936.\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m 'Jay Chou is 44 years old and the square of his age is 1936.'  Memory: 给Chains 和 Agents添加状态 至今为止，所有的链都是没有添加状态的。我们可以给chains和agents添加一些状态，让它能记住之前的信息。\nidea来源链接\n这里使用ConversationChain来实现\n1 2 3 4 5 6 7 8 9 10 11 12  from langchain import OpenAI, ConversationChain llm = OpenAI(temperature=0) conversation = ConversationChain(llm=llm, verbose=True) message = \u0026#34;林黛玉发疯文学是指林黛玉言辞敏感、自我、直爽，言词犀利​。举例：\\ 1.不自知的东西，照了镜子也没用 \\ 2.我就知道，别人不挑剩下来的也不会给我 \\ 3.你白认得我吗？我哪里能够像人家有什么配得上你的\\ 4.早知你今天来，我就不来了 \\ 5.难为你费心，哪里就冷死我了呢？\u0026#34; output = conversation.predict(input=message + \u0026#34;你现在理解了林黛玉发疯文学的写作形式了吗？\u0026#34;) print(output)   \u001b[1m\u0026gt; Entering new ConversationChain chain...\u001b[0m Prompt after formatting: \u001b[32;1m\u001b[1;3mThe following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know. Current conversation: Human: 林黛玉发疯文学是指林黛玉言辞敏感、自我、直爽，言词犀利​。举例： 1.不自知的东西，照了镜子也没用 2.我就知道，别人不挑剩下来的也不会给我 3.你白认得我吗？我哪里能够像人家有什么配得上你的 4.早知你今天来，我就不来了 5.难为你费心，哪里就冷死我了呢？你现在理解了林黛玉发疯文学的写作形式了吗？ AI:\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m 是的，我理解了林黛玉发疯文学的写作形式。它的特点是言辞敏感、自我、直爽，言词犀利，举例有：1.不自知的东西，照了镜子也没用；2.我就知道，别人不挑剩下来的也不会给我；3.你白认得我吗？我哪里能够像人家有什么配得上你的；4.早知你今天来，我就不来  1 2  output = conversation.predict(input=\u0026#34;如何用林黛玉发疯文学表达我不想见你？\u0026#34;) print(output)   \u001b[1m\u0026gt; Entering new ConversationChain chain...\u001b[0m Prompt after formatting: \u001b[32;1m\u001b[1;3mThe following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know. Current conversation: Human: 林黛玉发疯文学是指林黛玉言辞敏感、自我、直爽，言词犀利​。举例： 1.不自知的东西，照了镜子也没用 2.我就知道，别人不挑剩下来的也不会给我 3.你白认得我吗？我哪里能够像人家有什么配得上你的 4.早知你今天来，我就不来了 5.难为你费心，哪里就冷死我了呢？你现在理解了林黛玉发疯文学的写作形式了吗？ AI: 是的，我理解了林黛玉发疯文学的写作形式。它的特点是言辞敏感、自我、直爽，言词犀利，举例有：1.不自知的东西，照了镜子也没用；2.我就知道，别人不挑剩下来的也不会给我；3.你白认得我吗？我哪里能够像人家有什么配得上你的；4.早知你今天来，我就不来 Human: 如何用林黛玉发疯文学表达我不想见你？ AI:\u001b[0m \u001b[1m\u0026gt; Finished chain.\u001b[0m 我不想见你，你白认得我吗？我哪里能够像人家有什么配得上你的？早知你今天来，我就不来了，难为你费心，哪里就冷死我了呢？  建立一个语言模型应用: 对话模型 从对话模型中获取消息补全 Langchain中支持的message类型有AIMessage, HumanMessage, SystemMessage\n1 2 3 4 5 6 7 8 9 10 11  from langchain.chat_models import ChatOpenAI from langchain.schema import ( AIMessage, HumanMessage, SystemMessage ) chat = ChatOpenAI(temperature=0) # 对话补全 chat([HumanMessage(content=\u0026#34;区块链的作用有哪些？\u0026#34;)])   AIMessage(content='区块链的作用包括：\\n\\n1. 去中心化：区块链技术可以实现去中心化的数据存储和交易，不需要中心化的机构或第三方信任机构来验证和处理交易。\\n\\n2. 安全性：区块链技术采用密码学和分布式存储等技术，保证了数据的安全性和不可篡改性。\\n\\n3. 透明性：区块链技术可以实现公开透明的交易记录，任何人都可以查看和验证交易记录。\\n\\n4. 高效性：区块链技术可以实现快速的交易处理和结算，提高了交易的效率。\\n\\n5. 信任机制：区块链技术可以实现基于共识机制的信任机制，保证了交易的可信度和可靠性。\\n\\n6. 去中介化：区块链技术可以实现去除中介机构，降低交易成本和提高效率。\\n\\n7. 应用广泛：区块链技术可以应用于金融、物流、医疗、政府等各个领域，具有广泛的应用前景。', additional_kwargs={}, example=False)  1 2 3 4 5 6  # 使用多种类型信息，SystemMessage，HumanMessage messages = [ SystemMessage(content=\u0026#34;你是一个区块链专家，你现在帮助我了解区块链\u0026#34;), HumanMessage(content=\u0026#34;区块链中的去中心化是如何实现的？\u0026#34;) ] chat(messages)   AIMessage(content='区块链中的去中心化是通过分布式网络和共识机制来实现的。在区块链网络中，每个节点都可以参与到网络中，每个节点都有一个完整的副本，这些节点通过互相通信来达成共识，保证了数据的一致性和安全性。这种分布式的结构使得区块链网络没有中心化的控制机构，每个节点都是平等的，没有任何一个节点可以单独控制整个网络。\\n\\n共识机制是区块链中实现去中心化的关键。共识机制是指在区块链网络中，节点之间通过一定的算法来达成共识，保证数据的一致性和安全性。常见的共识机制包括工作量证明（PoW）、权益证明（PoS）、股份授权证明（DPoS）等。这些共识机制都是通过节点之间的竞争和协作来保证网络的安全性和去中心化。', additional_kwargs={}, example=False)  1 2 3 4 5 6 7 8 9 10 11 12 13  # 一次性加入多条信息 batch_messages = [ [ SystemMessage(content=\u0026#34;你是一个区块链专家，你现在帮助我了解区块链\u0026#34;), HumanMessage(content=\u0026#34;区块链如何保证安全性\u0026#34;) ], [ SystemMessage(content=\u0026#34;你是一个区块链专家，你现在帮助我了解区块链\u0026#34;), HumanMessage(content=\u0026#34;区块链如何实现透明性\u0026#34;) ], ] result = chat.generate(batch_messages) result   LLMResult(generations=[[ChatGeneration(text='区块链通过多种方式保证安全性，其中最重要的是使用密码学技术和共识机制。\\n\\n密码学技术包括公钥加密、哈希函数、数字签名等，这些技术可以保证数据的机密性、完整性和不可抵赖性。例如，每个区块都包含一个哈希值，这个哈希值是由区块中的所有交易数据计算得出的，如果有人篡改了其中的任何一笔交易，那么这个哈希值就会发生变化，从而被其他节点拒绝。\\n\\n共识机制是指在区块链网络中，所有节点必须达成一致的规则来验证和添加新的区块。常见的共识机制包括工作量证明（PoW）、权益证明（PoS）、权益证明加密（DPoS）等。这些机制可以防止恶意节点的攻击和篡改，从而保证整个网络的安全性。\\n\\n此外，区块链还采用了去中心化的架构，使得数据分布在整个网络中，没有单点故障，也没有中心化的控制机构，从而提高了安全性。', generation_info=None, message=AIMessage(content='区块链通过多种方式保证安全性，其中最重要的是使用密码学技术和共识机制。\\n\\n密码学技术包括公钥加密、哈希函数、数字签名等，这些技术可以保证数据的机密性、完整性和不可抵赖性。例如，每个区块都包含一个哈希值，这个哈希值是由区块中的所有交易数据计算得出的，如果有人篡改了其中的任何一笔交易，那么这个哈希值就会发生变化，从而被其他节点拒绝。\\n\\n共识机制是指在区块链网络中，所有节点必须达成一致的规则来验证和添加新的区块。常见的共识机制包括工作量证明（PoW）、权益证明（PoS）、权益证明加密（DPoS）等。这些机制可以防止恶意节点的攻击和篡改，从而保证整个网络的安全性。\\n\\n此外，区块链还采用了去中心化的架构，使得数据分布在整个网络中，没有单点故障，也没有中心化的控制机构，从而提高了安全性。', additional_kwargs={}, example=False))], [ChatGeneration(text='区块链实现透明性的方式是通过公开的、不可篡改的分布式账本来记录所有交易和操作。每个参与者都可以查看和验证这些记录，因此任何人都可以了解整个网络的状态和历史。此外，区块链上的智能合约也可以公开透明地执行，确保所有参与者都能够看到合约的执行结果。这种透明性可以帮助防止欺诈和不当行为，增加信任和可靠性。', generation_info=None, message=AIMessage(content='区块链实现透明性的方式是通过公开的、不可篡改的分布式账本来记录所有交易和操作。每个参与者都可以查看和验证这些记录，因此任何人都可以了解整个网络的状态和历史。此外，区块链上的智能合约也可以公开透明地执行，确保所有参与者都能够看到合约的执行结果。这种透明性可以帮助防止欺诈和不当行为，增加信任和可靠性。', additional_kwargs={}, example=False))]], llm_output={'token_usage': {'prompt_tokens': 97, 'completion_tokens': 487, 'total_tokens': 584}, 'model_name': 'gpt-3.5-turbo'})  对话prompt模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  from langchain.chat_models import ChatOpenAI from langchain.prompts.chat import ( ChatPromptTemplate, SystemMessagePromptTemplate, HumanMessagePromptTemplate, ) chat = ChatOpenAI(temperature=0) template = \u0026#34;You are a helpful assistant that translates {input_language}to {output_language}.\u0026#34; system_message_prompt = SystemMessagePromptTemplate.from_template(template) human_template = \u0026#34;{text}\u0026#34; human_message_prompt = HumanMessagePromptTemplate.from_template(human_template) chat_prompt = ChatPromptTemplate.from_messages([system_message_prompt, human_message_prompt]) # get a chat completion from the formatted messages chat(chat_prompt.format_prompt(input_language=\u0026#34;English\u0026#34;, output_language=\u0026#34;French\u0026#34;, text=\u0026#34;I love programming.\u0026#34;).to_messages())   AIMessage(content=\u0026quot;J'adore la programmation.\u0026quot;, additional_kwargs={}, example=False)  chains和对话模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  from langchain.chat_models import ChatOpenAI from langchain import LLMChain from langchain.prompts.chat import ( ChatPromptTemplate, SystemMessagePromptTemplate, HumanMessagePromptTemplate, ) chat = ChatOpenAI(temperature=0) template = \u0026#34;You are a helpful assistant that translates {input_language}to {output_language}.\u0026#34; system_message_prompt = SystemMessagePromptTemplate.from_template(template) human_template = \u0026#34;{text}\u0026#34; human_message_prompt = HumanMessagePromptTemplate.from_template(human_template) chat_prompt = ChatPromptTemplate.from_messages([system_message_prompt, human_message_prompt]) # 使用chain chain = LLMChain(llm=chat, prompt=chat_prompt) chain.run(input_language=\u0026#34;English\u0026#34;, output_language=\u0026#34;French\u0026#34;, text=\u0026#34;I love programming.\u0026#34;) # -\u0026gt; \u0026#34;J\u0026#39;aime programmer.\u0026#34;   \u0026quot;J'adore la programmation.\u0026quot;  agents和对话模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  from langchain.agents import load_tools from langchain.agents import initialize_agent from langchain.agents import AgentType from langchain.chat_models import ChatOpenAI from langchain.llms import OpenAI # First, let\u0026#39;s load the language model we\u0026#39;re going to use to control the agent. chat = ChatOpenAI(temperature=0) # Next, let\u0026#39;s load some tools to use. Note that the `llm-math` tool uses an LLM, so we need to pass that in. llm = OpenAI(temperature=0) tools = load_tools([\u0026#34;serpapi\u0026#34;, \u0026#34;llm-math\u0026#34;], llm=llm) # Finally, let\u0026#39;s initialize an agent with the tools, the language model, and the type of agent we want to use. agent = initialize_agent(tools, chat, agent=AgentType.CHAT_ZERO_SHOT_REACT_DESCRIPTION, verbose=True) # Now let\u0026#39;s test it out! agent.run(\u0026#34;How old is Jay Chou now? What is the square of his age?\u0026#34;)   Message: 给chains和agents添加状态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  from langchain.prompts import ( ChatPromptTemplate, MessagesPlaceholder, SystemMessagePromptTemplate, HumanMessagePromptTemplate ) from langchain.chains import ConversationChain from langchain.chat_models import ChatOpenAI from langchain.memory import ConversationBufferMemory prompt = ChatPromptTemplate.from_messages([ SystemMessagePromptTemplate.from_template(\u0026#34;The following is a friendly conversation between a human and an AI. The AI is talkative and provides lots of specific details from its context. If the AI does not know the answer to a question, it truthfully says it does not know.\u0026#34;), MessagesPlaceholder(variable_name=\u0026#34;history\u0026#34;), HumanMessagePromptTemplate.from_template(\u0026#34;{input}\u0026#34;) ]) llm = ChatOpenAI(temperature=0) memory = ConversationBufferMemory(return_messages=True) conversation = ConversationChain(memory=memory, prompt=prompt, llm=llm) conversation.predict(input=\u0026#34;Hi there!\u0026#34;)   'Hello! How can I assist you today?'  1  conversation.predict(input=\u0026#34;I\u0026#39;m doing well! Just having a conversation with an AI.\u0026#34;)   \u0026quot;That sounds like fun! I'm happy to chat with you. Is there anything specific you'd like to talk about?\u0026quot;  1  conversation.predict(input=\u0026#34;Tell me about yourself.\u0026#34;)   \u0026quot;Sure! I am an AI language model designed to assist with various tasks such as answering questions, generating text, and providing recommendations. I was created using natural language processing techniques and machine learning algorithms, which allow me to understand and respond to human language. I am constantly learning and improving based on the interactions I have with users like you. Is there anything else you'd like to know?\u0026quot;  ","date":"2023-05-10T00:00:00Z","permalink":"https://jhrsya.github.io/p/langchain/","title":"langchain"},{"content":"货币的界碑 比特币是一串加密字符，本身毫无价值，更没有所谓“内在价值”。但各国的货币本身也没有内在价值，都依赖本国政府的信用而流通。比特币是依靠技术信用在而流通。所谓技术信用，是比特币借用一套叫作“区块链”的技术体系，塑造了全公开、分布式、防篡改、可追溯的数据库，这个数据库任何人都可以查看，公开透明，极难篡改，实际上是一种脱离任何人控制的存在，因此获得很多人的信任。既然政府信用可以支撑价值几百万亿美元的主权货币，技术信用支撑价值区区几千亿美元的比特币，就毫不奇怪了。\n任何资产价值的背后，终究是信用。\n货币超发的危害：\n 通货膨胀，即货币贬值 劫富济贫：超发的货币，并不是在人群中均匀分布的，总是有人先拿到，有人后拿到。先拿到的，往往是主流的金融机构和大型商业机构，成本很低。后拿到的人，则不得不用自己的劳动和资产去交换，成本很高。 惩罚诚实，奖励贪婪  货币增发是一次巨大的财富再分配，靠近印钞机的人获益、分享铸币税，远离印钞机的人受损、缴纳铸币税。\n市场一旦建立，价格就开始上涨。市场是发现价格、汇聚资源、创造奇迹的地方。市场这个开放的体系，是人类很多奇迹的根源，离开这个开放的体系，人类无法成长。一切封闭的体系，尽管设计精良，终究都没有生命力。\n一个新生事物被纳入法律监管，如果监管不是特别严厉，在一定意义上可以看作变相的承认，甚至是支持。纳入监管之前，没有界限，任何行为都可能受到约束，风险很大。纳入监管之后，就有了界限，可以逐步形成稳定预期，企业的发展其实是更便利了。\n","date":"2023-05-10T00:00:00Z","permalink":"https://jhrsya.github.io/p/%E8%B4%A7%E5%B8%81%E7%9A%84%E7%95%8C%E7%A2%91/","title":"货币的界碑"},{"content":"垃圾回收 java java虚拟机中的内存划分 java垃圾回收 引用计数算法 给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器值为0的对象就是不能再被使用的。\n引用计数法无法解决对象之间循环引用的问题。\n可达性分析算法 这个算法的基本思想是通过一系列称为GC Roots的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时（用图论的话来说，就是从GC Roots到这个对象不可达），则证明此对象是不可用的。 在java语言中，可作为GC Roots的对象包括下面几种：\n 虚拟机栈(帧栈中的本地变量表)中引用的对象 方法区中类静态属性引用的变量 方法区中常量引用的对象 本地方法栈中(即一般说的Native方法)引用的对象  java中引用的概念 java对引用的概念进行了扩充：分为强引用，软引用，弱引用，虚引用。\n 强引用就是在程序代码中普遍存在的，类似Object obj = new Object()这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用是用来描述一些还有用但是非必须得对象。 弱引用也是用来描述非必须得对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱应用关联的对象。 虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存事件造成影响，也无法通过虚引用来获得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被垃圾收集器回收时收到一个系统通知。  ","date":"2023-05-07T00:00:00Z","permalink":"https://jhrsya.github.io/p/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/","title":"垃圾回收"},{"content":"postgresql postgresql下载与配置 ubantu下载postgresql:\n1 2  sudo apt update sudo apt install postgresql   如何需要让远程的主机连接上服务器上的postgresql，需要设置/etc/postgresql/14/main/postgresql.conf和/etc/postgresql/14/main/pg_hba.conf中的两个文件\n把/etc/postgresql/14/main/postgresql.conf中的listen_address设置为listen_addresses = '*', 把/etc/postgresql/14/main/pg_hba.conf修改为\n1 2  # IPv4 local connections: host all all 0.0.0.0/0 trust   接着重启服务sudo systemctl restart postgresql 或者不重启重新载入配置文件sudo systemctl reload postgresql \npostgresql操作 使用psql进入后的操作  执行sql文件  1  \\i path # path必须是/或者\\\\连接，不能使用\\   查看数据库中有多少张表 \\d 查看表的结构 \\d table_name  使用peewee操作postgresql的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # 查询所有的用户 users = User.select() # 查询指定条件的用户,可以使用filter也可以使用where users = User.select().where(User.username == \u0026#39;john\u0026#39;) \u0026#34;\u0026#34;\u0026#34; filter()方法是一个查询构建器的方法，它用于向现有查询中添加筛选条件，并返回一个新的查询对象。 where()方法是查询对象的方法，用于指定查询条件。与filter()方法不同，它会直接修改当前查询对象，并返回自身。 \u0026#34;\u0026#34;\u0026#34; new_query = query.filter(User.age \u0026gt; 18) query.where(User.age \u0026gt; 18) # 对查询结果进行排序 users = User.select().order_by(User.username.desc()) # 对查询结果进行分页 users = User.select().paginate(1, 10) # 对查询结果进行聚合操作 from peewee import fn total_users = User.select(fn.COUNT(User.id)) # 使用Peewee的ORM方法进行数据库操作 user = User.create(username=\u0026#39;john\u0026#39;, email=\u0026#39;john@example.com\u0026#39;, password=\u0026#39;password\u0026#39;) # 使用Peewee的ORM方法更新数据库中的记录 user.email = \u0026#39;john@newemail.com\u0026#39; user.save() # 使用Peewee的ORM方法删除数据库中的记录 user.delete_instance()   create 1 2 3  # 使用Peewee的ORM方法进行数据库操作 user = User.create(username=\u0026#39;john\u0026#39;, email=\u0026#39;john@example.com\u0026#39;, password=\u0026#39;password\u0026#39;) user.save()   read 1 2 3 4 5 6 7 8  # 查询所有的用户 users = User.select() # peewee.Model # 查询指定条件的用户 users = User.select().where(User.username == \u0026#39;john\u0026#39;) # peewee.Model # 使用filter进行查询，User.filter() 等价于 User.select().where() users = User.filter(User.username == \u0026#39;john\u0026#39;) # peewee.Model   只获取一个实例\n1  user = User.get(User.username == \u0026#39;john\u0026#39;) # User   update 1 2 3  query = User.update({User.name: \u0026#39;steve\u0026#39;}).where(User.name == \u0026#39;john\u0026#39;) affected_rows = query.execute() # affected_rows返回已经更新的行数，0则没有更新   delete 1 2 3 4  # 删除记录 query = Wallet.delete().where(Wallet.user_id == 9) affected_rows = query.execute() # affected_rows返回已经删除的行数，0则为没有删除   ","date":"2023-05-05T00:00:00Z","permalink":"https://jhrsya.github.io/p/postgresql/","title":"postgresql介绍"},{"content":"一致性哈希算法 一致性哈希算法（Consistent Hashing）是一种常用的分布式哈希算法，通常用于实现负载均衡和缓存系统，特别是在大规模的分布式系统中。以下是一些可能使用一致性哈希算法的示例：\n 缓存系统：在缓存系统中，一致性哈希算法可以用来选择缓存节点，以便快速存储和检索数据。一致性哈希算法可以使缓存系统中的缓存节点数量变化时，尽可能减少缓存节点的重新分配。 负载均衡：在负载均衡中，一致性哈希算法可以用来选择服务器，以便将客户端请求均匀地分配到各个服务器上。使用一致性哈希算法可以保持服务器数量的变化，而不需要重新分配所有的请求。 分布式文件系统：在分布式文件系统中，一致性哈希算法可以用来选择节点，以便将文件分配到不同的节点上。一致性哈希算法可以避免在节点数量发生变化时，需要重新分配文件的问题。 分布式数据库：在分布式数据库中，一致性哈希算法可以用来选择节点，以便将数据分配到不同的节点上。一致性哈希算法可以避免在节点数量发生变化时，需要重新分配数据的问题。  总之，一致性哈希算法可以用于任何需要在分布式系统中动态分配和选择节点的场景，以便实现高效的负载均衡和分布式存储。\n一致性哈希算法在nginx中的应用 Nginx是一种流行的Web服务器和反向代理服务器，它也被广泛用于负载均衡和高可用性的应用程序中。\n在Nginx中，一致性哈希算法通常用于实现基于IP地址或其他请求参数的负载均衡。具体来说，Nginx可以使用一致性哈希算法来选择服务器，以便将请求路由到正确的服务器上。\n在Nginx的一致性哈希实现中，可以使用一致性哈希模块来实现。该模块可以将请求的哈希值映射到一组服务器中的一个，以实现负载均衡。一致性哈希模块还可以支持动态添加或删除服务器，并保持负载均衡策略的一致性。\n哈希函数 Nginx使用了MurmurHash哈希函数来计算键的哈希值。MurmurHash是一种高效的哈希函数，它在计算哈希值时可以避免哈希碰撞。\nMurmurHash是一种快速的非加密哈希函数，它的设计旨在提供良好的随机性、均匀性和高性能。MurmurHash的哈希算法比其他常见的哈希算法如MD5和SHA-1要快得多，并且在分布式系统中的负载均衡和数据分片中被广泛使用。\nMurmurHash算法的主要思想是利用位操作和乘法来处理输入数据，并使用分离的哈希状态来生成哈希值。具体来说，MurmurHash算法将输入数据按照一定的规则分割成若干个32位的块，每个块都会对哈希状态进行更新，然后将最终的哈希状态转换为哈希值输出。\n举个例子，如果一个来了一个ip地址请求，murmurhash是如何处理的？\n  初始化哈希状态 MurmurHash算法使用两个32位的常量来初始化哈希状态，其中一个常量是随机选择的，另一个常量是固定的。假设我们选择的随机常量为0x5bd1e995，固定常量为0x9747b28c。\n  处理输入数据 我们将IP地址按照一定的规则转换为32位整数，并将其作为输入数据。假设IP地址为192.168.1.100，对应的32位整数为0xc0a80164。根据MurmurHash算法的规则，我们需要将这个32位整数按照如下方式处理:\n 将32位整数分为四个8位的字节，即0xc0、0xa8、0x01和0x64。 将每个字节转换为32位整数，即0x000000c0、0x000000a8、0x00000001和0x00000064。 将这些32位整数按照一定的规则进行位运算和乘法，生成一个新的32位整数。假设这个新的32位整数为0x3f6e3d6f。  我们将生成的新的32位整数0x3f6e3d6f作为输入数据，对哈希状态进行更新。具体来说，我们将新的32位整数作为参数，调用一个哈希状态更新函数，该函数会对哈希状态进行混合，使得哈希状态随着输入数据的变化而变化。\n  结束哈希状态 当输入数据处理完成时，我们使用一些位运算和乘法来结束哈希状态。具体来说，我们对哈希状态进行一些最终的混合和变换，使得哈希状态满足一定的分布特性。\n  生成哈希值 最后，我们将哈希状态转换为哈希值输出。通常情况下，哈希值会被截取为固定长度的位数，并进行适当的调整和变换，以保证其满足特定的需求。假设我们将哈希值截取为16位，即0x3d6f，作为IP地址的哈希值。\n  在负载均衡场景中，我们可以使用IP地址的哈希值来决定该请求应该由哪个服务器来处理。\n一致性哈希环 Nginx使用了一致性哈希环来存储服务器节点和键的哈希值。服务器节点在环上分布，并且每个键都可以映射到一个服务器节点。这种设计可以使负载均衡策略在添加或删除服务器时保持一致性。\n一致性哈希环是一种数据结构，用于实现一致性哈希算法。它由一个环形结构组成，每个节点在环上对应一个哈希值，表示一个服务器或者节点。通常情况下，哈希值是一个整数，通常使用32位或64位无符号整数。\n一致性哈希环的构建过程如下：\n  计算服务器哈希值 对于每个服务器，使用哈希算法计算其哈希值。通常情况下，可以使用服务器的IP地址或者主机名作为输入数据进行哈希，以保证每个服务器的哈希值是唯一的。\n  在环上分配节点 将所有的服务器节点按照其哈希值，在环上分配节点。通常情况下，可以使用哈希值对环进行分片，每个节点对应一个分片。分片的数量可以根据具体情况进行调整，通常情况下，分片的数量应该比较大，以保证分布均匀。\n  计算对象哈希值 对于每个对象，使用哈希算法计算其哈希值。通常情况下，可以使用对象的ID或者键值作为输入数据进行哈希，以保证每个对象的哈希值是唯一的。\n  在环上查找节点 将对象的哈希值映射到环上的某个节点。具体来说，从对象的哈希值开始沿着环顺时针方向查找，找到第一个大于等于该哈希值的节点。如果没有找到该节点，则将对象映射到环上的第一个节点。\n  一致性哈希环的优点是可以动态添加或删除服务器节点，而不会影响大部分对象的映射。具体来说，当添加或删除一个服务器节点时，只有该节点周围的对象映射会发生变化，其他节点的对象映射仍然保持不变。这样可以避免大量对象的重新映射，提高一致性哈希算法的效率和可扩展性。\n一致性哈希环还可以使用虚拟节点技术来提高负载均衡的效率和稳定性。具体来说，对于每个服务器节点，可以在环上分配多个虚拟节点，每个虚拟节点对应一个哈希值。这样可以使得服务器节点在环上的分布更加均匀，从而提高负载均衡的效率和稳定性。\n节点选择 当一个请求到达时，Nginx会计算请求键的哈希值，并将其映射到一致性哈希环上。然后，Nginx会选择最近的服务器节点，并将请求转发到该节点上。如果该节点不可用，则Nginx会选择下一个最近的节点。\n动态添加或删除服务器 在Nginx的一致性哈希模块中，可以动态添加或删除服务器，并保持负载均衡策略的一致性。当添加或删除服务器时，Nginx会重新计算哈希环，并将请求转发到新的服务器节点。\n","date":"2023-05-05T00:00:00Z","permalink":"https://jhrsya.github.io/p/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/","title":"一致性哈希算法"},{"content":"cpp 关键字 1. volatile volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。\n2. override 告诉编译器一定是重写了父类的函数，不然就会报错。\n1 2 3 4 5 6 7 8 9  class A { virtual void foo(); }; class B : public A { virtual void f00(); //OK，这个函数是B新增的，不是继承的  virtual void f0o() override; //Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错 };   3. final 当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Base { virtual void foo(); }; class A : public Base { void foo() final; // foo 被override并且是最后一个override，在其子类中不可以重写 }; class B final : A // 指明B是不可以被继承的 { void foo() override; // Error: 在A中已经被final了 }; class C : B // Error: B is final { };   4. explicit explicit修饰构造函数时，如果构造函数存在隐式转换，编译时会报错。只能显示的使用构造函数。\n5. static 当static用于变量时，它可以用于控制变量的可见范围。具体来说，如果一个变量被声明为static，那么它只能在当前文件中使用，而无法被其他文件访问。这样可以防止变量被意外修改或者在不同的文件中出现命名冲突。\n当static用于函数时，它可以用于控制函数的可见范围。具体来说，如果一个函数被声明为static，那么它只能在当前文件中使用，而无法被其他文件调用。这样可以确保函数只被用于当前文件，避免了函数名冲突和重复定义的问题。\n需要注意的是，static还可以用于类的成员变量和成员函数，此时它的作用类似于在全局作用域下的变量和函数。对于static成员变量，所有类的实例都共享同一个变量，对它的修改会影响所有实例。对于static成员函数，它不会访问任何实例数据，也不需要this指针，因此可以直接通过类名来调用。\n拷贝构造函数和拷贝赋值函数 都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将对象的值复制给一个已经存在的实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  #include \u0026lt;cstring\u0026gt; class MyString { public: // 构造函数  MyString() { m_data = new char[1]; *m_data = \u0026#39;\\0\u0026#39;; } MyString(const char* str) { if (str == nullptr) { m_data = new char[1]; *m_data = \u0026#39;\\0\u0026#39;; } else { int len = strlen(str); m_data = new char[len + 1]; strcpy(m_data, str); } } // 拷贝构造函数  MyString(const MyString\u0026amp; other) { int len = strlen(other.m_data); m_data = new char[len + 1]; strcpy(m_data, other.m_data); } // 拷贝赋值函数  MyString\u0026amp; operator=(const MyString\u0026amp; other) { if (this != \u0026amp;other) { char* tmp = new char[strlen(other.m_data) + 1]; strcpy(tmp, other.m_data); delete[] m_data; m_data = tmp; } return *this; } // 析构函数  ~MyString() { delete[] m_data; } private: char* m_data; };   野指针和悬空指针 野指针：没有被初始化的指针。 悬空指针：最初指向的内存已经被释放了的一种指针。\n产生原因及解决办法： 野指针：指针变量未及时初始化 =\u0026gt; 定义指针变量及时初始化，要么置空。 悬空指针：指针free或delete之后没有及时置空 =\u0026gt; 释放操作后立即置空。\n内联函数和宏定义的区别  在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义。 内联函数有类型检测、语法判断等功能，而宏没有。  内联函数适用场景:\n 使用宏定义的地方都可以使用 inline 函数。 作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。  在 Java 中，可以使用关键字 final 来修饰方法，使其成为 final 方法，从而在编译期间实现类似于 inline 函数的效果。final 方法在编译期间会被直接替换到调用该方法的地方，而不是像普通方法一样需要在运行时才能动态绑定。\n在 Go 语言中，没有类似于 C++ 中的 inline 关键字，但是 Go 编译器会在适当的情况下自动将函数内联。Go 编译器会在编译时进行函数内联，这样可以减少函数调用的开销，提高程序的执行效率。\nvolatile、mutable和explicit关键字的用法 volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。\nmutable表示可变的，在常函数里也可以被修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class person { int m_A; mutable int m_B;//特殊变量 在常函数里值也可以被修改 public: void add() const//在函数里不可修改this指针指向的值 常量指针  { m_A=10;//错误 不可修改值，this已经被修饰为常量指针  m_B=20;//正确  } } class person { int m_A; mutable int m_B;//特殊变量 在常函数里值也可以被修改 } int main() { const person p;//修饰常对象 不可修改类成员的值 p.m_A=10;//错误，被修饰了指针常量 p.m_B=200;//正确，特殊变量，修饰了mutable }   explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换，注意以下几点：\n explicit 关键字只能用于类内部的构造函数声明上 explicit 关键字作用于单个参数的构造函数 被explicit修饰的构造函数的类，不能发生相应的隐式类型转换  RAII(资源获取即初始化) 原因：在对象初始化时，如果调用构造函数时发生了异常，这之前已经调用了operator new函数分配了内存，那么就会导致内存泄漏，解决方法是使用try-catch块来捕获构造函数中的异常，并在发生异常时显式地调用 operator delete 函数以释放已分配的内存。\n但是上面的解决方案显然太麻烦，可以使用RAII来解决这个问题。 RAII（资源获取即初始化）是一种C++编程技术，它利用了对象的生命周期来管理资源。通过在对象的构造函数中获取资源，在对象的析构函数中释放资源，可以确保在任何情况下都能正确地释放资源，从而避免内存泄漏等问题。\n当 RAII 对象被创建时，构造函数被调用，并分配了相应的资源；当 RAII 对象超出作用域时，析构函数被自动调用，以释放之前分配的资源。如果构造函数中发生异常，则该 RAII 对象的构造未能成功完成，因此该对象不应该继续存在。因此，C++ 编译器会自动调用析构函数来清理该对象占用的资源。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class Resource { public: Resource() { // 分配内存  m_data = new int[100]; } ~Resource() { // 释放内存  delete[] m_data; } private: int* m_data; }; class MyClass { public: MyClass() { // 在构造函数中使用资源管理类分配内存  m_resource = new (std::nothrow) Resource; if (!m_resource) { // 处理内存分配失败的情况  throw std::bad_alloc(); } } ~MyClass() { // 在析构函数中释放内存  delete m_resource; } private: Resource* m_resource; };   在上面的代码中，我们使用了 C++11 中的 std::nothrow，它表示如果内存分配失败不会抛出异常，而是返回一个空指针。如果内存分配失败，我们可以在构造函数中处理这种情况，例如抛出 std::bad_alloc 异常，然后外部的代码就可以根据需要进行处理。\n零拷贝 零拷贝是一种技术，它可以在不复制数据的情况下，在不同的进程或线程之间传输数据。 零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。 零拷贝技术可以减少数据拷贝和共享总线操作的次数。 在C++中，vector的一个成员函数**emplace_back()**很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：使用push_back()函数需要调用构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发构造函数和转移构造函数，效率更高。举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  #include \u0026lt;vector\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; struct Person { string name; int age; //初始构造函数  Person(string p_name, int p_age): name(std::move(p_name)), age(p_age) { cout \u0026lt;\u0026lt; \u0026#34;I have been constructed\u0026#34; \u0026lt;\u0026lt;endl; } //拷贝构造函数  Person(const Person\u0026amp; other): name(std::move(other.name)), age(other.age) { cout \u0026lt;\u0026lt; \u0026#34;I have been copy constructed\u0026#34; \u0026lt;\u0026lt;endl; } //转移构造函数  Person(Person\u0026amp;\u0026amp; other): name(std::move(other.name)), age(other.age) { cout \u0026lt;\u0026lt; \u0026#34;I have been moved\u0026#34;\u0026lt;\u0026lt;endl; } }; int main() { vector\u0026lt;Person\u0026gt; e; cout \u0026lt;\u0026lt; \u0026#34;emplace_back:\u0026#34; \u0026lt;\u0026lt;endl; e.emplace_back(\u0026#34;Jane\u0026#34;, 23); //不用构造类对象  vector\u0026lt;Person\u0026gt; p; cout \u0026lt;\u0026lt; \u0026#34;push_back:\u0026#34;\u0026lt;\u0026lt;endl; p.push_back(Person(\u0026#34;Mike\u0026#34;,36)); return 0; } //输出结果： //emplace_back: //I have been constructed //push_back: //I have been constructed //I am being moved.   右值 右值引用使用 \u0026amp;\u0026amp; 符号表示。 在 C++ 中，右值指的是那些在表达式求值期间创建的临时对象、字面常量、表达式、返回右值引用的函数调用等，它们都是临时的、短暂的，不能被持久化或修改，因此右值只能被拷贝或移动，不能被赋值或取地址。 右值引用通常用于实现移动语义和完美转发。移动语义可以避免在资源管理类中进行不必要的复制操作，提高程序的性能。完美转发可以实现将参数按原样传递给下一层函数，同时避免不必要的复制操作。 举个完美转发的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #include \u0026lt;iostream\u0026gt;#include \u0026lt;utility\u0026gt; void foo(int \u0026amp;x) { std::cout \u0026lt;\u0026lt; \u0026#34;foo(int\u0026amp;): \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } void foo(int \u0026amp;\u0026amp;x) { std::cout \u0026lt;\u0026lt; \u0026#34;foo(int\u0026amp;\u0026amp;): \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } template\u0026lt;typename T\u0026gt; void bar(T \u0026amp;\u0026amp;x) { foo(std::forward\u0026lt;T\u0026gt;(x)); } int main() { int x = 42; bar(x); // 输出 foo(int\u0026amp;): 42  bar(3); // 输出 foo(int\u0026amp;\u0026amp;): 3  bar(std::move(x)); // 输出 foo(int\u0026amp;\u0026amp;): 42 完美转发  return 0; }   组合 是has-a的关系。 在C++中，组合（Composition）是一种面向对象编程的概念，指的是一个类（称为容器类）包含另外一个类（称为成员类）的对象作为自己的成员。组合实现了代码的复用，使得一个类可以重用另一个类的实现而不必从头开始编写代码。\n通过组合，一个类可以将另一个类的功能集成到自己的功能中。例如，一个汽车类可以包含一个引擎类的对象，从而实现汽车的动力系统。另一个例子是，一个图形类可以包含一个点类的对象，从而实现图形的定位和形状。\n在C++中，组合的实现方式是将成员对象作为容器类的私有成员变量。容器类可以通过调用成员对象的公共接口来访问和操作成员对象的状态和行为。由于成员对象是容器类的一部分，因此成员对象的生命周期和容器类的生命周期是一样的。\n函数指针 函数指针是指向函数的指针变量，可以用来存储和调用函数。在C++中，函数名可以视为一个指向函数的指针，因此可以将函数名赋值给一个函数指针变量，然后通过该变量来调用函数。 函数指针的语法如下：return-type (*pointer-name)(argument-list);\n函数指针可以用来传递函数作为参数，或者用来返回函数作为返回值。这在一些高级的编程场景中非常有用，例如回调函数、函数对象等。 函数对象是一种将函数封装为对象的技术。通过函数对象，可以将函数与数据结构相结合，形成一个新的数据类型，从而实现更加灵活的程序设计。函数对象广泛应用于标准模板库（STL）中，例如在算法中传递比较函数、排序函数等。\n举例如何使用函数指针来实现回调函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;iostream\u0026gt;using namespace std; // 加法函数 int add(int a, int b) { return a + b; } // 减法函数 int subtract(int a, int b) { return a - b; } // 计算函数 int calculate(int a, int b, int (*p)(int, int)) { return p(a, b); } int main() { int a = 3, b = 4; int result; // 使用加法函数进行计算  result = calculate(a, b, add); cout \u0026lt;\u0026lt; \u0026#34;Addition result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; // 使用减法函数进行计算  result = calculate(a, b, subtract); cout \u0026lt;\u0026lt; \u0026#34;Subtraction result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; return 0; }   内存对齐 内存对齐（Memory Alignment）是指在计算机中为了提高数据读取效率而采取的一种数据对齐方式。在C++中，编译器会根据结构体中成员变量的数据类型和顺序来决定如何分配内存，以保证每个成员变量被正确地对齐。具体来说，对于每个成员变量，编译器会将其分配在地址可以被其大小整除的位置上，以确保读取时能够高效地访问。\n内存对齐可以提高数据读取效率的原因是，当数据被存储到内存中时，计算机通常会将数据一次性读取到缓存中，以便快速访问。如果数据没有按照特定的对齐方式存储在内存中，读取时就需要额外的处理，从而导致读取效率降低。\n共享内存的实现方式 共享内存是指多个进程可以同时访问同一个物理内存区域，它是实现进程间通信的一种方式，可以提高进程间通信的效率。\n共享内存的实现方式主要有两种：基于文件和基于匿名映射。\n基于文件的共享内存实现方式：将共享内存映射到一个文件中，多个进程可以通过访问该文件来访问共享内存。具体实现过程如下：\n（1）使用shmget()函数创建或打开一个共享内存对象，并返回一个标识符。 （2）使用shmat()函数将共享内存对象映射到进程的地址空间中。 （3）多个进程可以通过访问共享内存对象所在的文件来访问共享内存。 （4）使用shmdt()函数将共享内存对象从进程的地址空间中分离。 （5）使用shmctl()函数控制共享内存对象。\n基于匿名映射的共享内存实现方式：不需要映射到文件中，直接将共享内存映射到进程的地址空间中。具体实现过程如下：\n（1）使用mmap()函数创建一个匿名映射区域，该区域被多个进程共享。 （2）多个进程可以通过访问该匿名映射区域来访问共享内存。 （3）使用munmap()函数释放匿名映射区域。\n需要注意的是，在使用共享内存时需要考虑进程间同步的问题，以避免数据的不一致性。可以使用信号量等进程间同步机制来保证多个进程对共享内存的访问顺序和正确性。此外，还需要考虑共享内存的大小和释放问题，避免内存泄漏和过度占用内存等问题。\n匿名函数 C++中可以使用lambda表达式定义匿名函数。lambda表达式是C++11引入的一种语法，用于定义匿名函数。\nlambda表达式的基本语法如下： [capture-list](parameter-list) -\u0026gt; return-type { function-body }\n其中：\n capture-list表示捕获列表，用于捕获外部变量。 parameter-list表示参数列表，与普通函数的参数列表类似。 return-type表示返回值类型，可以省略，编译器会自动推导。 function-body表示函数体，与普通函数的函数体类似。  无捕获列表示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #include \u0026lt;iostream\u0026gt; int main() { // 定义一个lambda表达式  auto greet = []() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, world!\u0026#34; \u0026lt;\u0026lt; std::endl; }; // 直接调用lambda表达式  greet(); return 0; }   捕获列表有三种形式：值捕获、引用捕获和隐式捕获。用于捕获外部变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;iostream\u0026gt; int main() { int a = 10; // 定义一个lambda表达式，捕获外部变量a的值  // lambda表达式创建时复制一份外部变量的值，并在函数体中使用  auto add = [a](int b) { return a + b; }; // 调用lambda表达式  std::cout \u0026lt;\u0026lt; add(20) \u0026lt;\u0026lt; std::endl; // 输出 30  return 0; }   ","date":"2023-05-04T00:00:00Z","permalink":"https://jhrsya.github.io/p/cpp/","title":"cpp_notes"},{"content":"go go不同点：\n go如果声明了变量，那一定要使用，不然会报错 go没有 i++ 和 i-- go 没有返回值不用设置为void ，直接不设置返回值就可以 go 里面切片不能使用负值，比如-1 go中变量名和函数返回值都是写在变量名和函数返回值的后面 go是面向接口编程 go中的const可以定义枚举类型 c++, java抛异常都是用throw, go 用panic, python用raise  go提供的数据结构 1. 数组 var arr [3]int\n2. 切片(slice) 动态数组var arr []int\n3. 映射 map: 底层用哈希表实现 声明并初始化：m := map[string]int {\u0026quot;one\u0026quot;: 1, \u0026quot;two: 2} map的打印顺序是无法确定的，是随机的，是一种无序的键值对集合。 go中没有有序的键值对集合，可以使用slice和struct实现有序的键值对结合。\n关键字 1. make make 是一个用来创建某些类型的引用对象的内建函数。 具体来说，make 用于创建 slice、map 和 channel 类型的对象，而不是创建值类型的对象（例如 int、float 等）。 make后才会分配内存空间。\ngo并发 1. go关键字 Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine(协程)，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。\n2. channel关键字 默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。\n如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。\n带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。\n总结：goroutine之间的通信可以通过channel来实现。\ngo面向接口编程 在 Go 语言中，如果要继承一个接口，你只需要在结构体中实现该接口声明的所有方法。 这种依靠实现方法匹配度的继承方式，就是鸭子类型：如果一个动物看起来像鸭子，叫起来也像鸭子，那它一定是鸭子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // 定义 Animal 接口 interface Animal { Eat() // 声明 Eat 方法  Move() // 声明 Move 方法 } // ==== 定义 Dog Start ==== // 定义 Dog 类 type Dog struct { } // 实现 Eat 方法 func (d *Dog) Eat() { fmt.Printf(\u0026#34;Eating bones\u0026#34;) } // 实现 Move 方法 func (d *Dog) Move() { fmt.Printf(\u0026#34;Moving with four legs\u0026#34;) } // ==== 定义 Dog End ====  // ==== 定义 Human Start ==== // 定义 Human 类 type Human struct { } // 实现 Eat 方法 func (h *Human) Eat() { fmt.Printf(\u0026#34;Eating rice\u0026#34;) } // 实现 Move 方法 func (h *Human) Move() { fmt.Printf(\u0026#34;Moving with two legs\u0026#34;) } // ==== 定义 Human End ====   go错误处理 Go 语言要求开发者自己管理错误，也就是在函数中的错误需要显式抛出来，否则 Go 程序不会做任何错误处理。因为 Go 没有传统编程语言的 try/catch 针对错误处理的语法，所以在错误管理上缺少灵活度，导致了 “err 满天飞” 的局面。\ngo错误处理的好处：第一，它强制要求 Go 语言开发者从代码层面来规范错误的管理方式，这驱使开发者写出更健壮的代码；第二，这种显式返回错误的方式避免了 “try/catch 一把梭”，因为这种 “一时爽” 的做法很可能导致 Bug 无法准确定位，从而产生很多不可预测的问题；第三，由于没有 try/catch 的括号或额外的代码块，Go 程序代码整体看起来更清爽，可读性较强。\ngo匿名函数 在Go语言中，func(){}表示一个匿名函数（没有函数名），它可以作为值进行传递，也可以被直接调用。\n当在func(){}后面添加一个括号对()时，它表示直接调用这个匿名函数。也就是说，func(){}()中第二个括号的内容为空，表示直接调用前面定义的匿名函数，并将其返回值（如果有）作为整个表达式的值。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  package main import \u0026#34;fmt\u0026#34; func main() { // 定义一个匿名函数  greet := func() { fmt.Println(\u0026#34;Hello, world!\u0026#34;) } // 直接调用匿名函数  greet() }   func(x int){}(10)第一个括号中表示函数的形参，第二个括号是函数调用时传入的实参。\n","date":"2023-05-04T00:00:00Z","permalink":"https://jhrsya.github.io/p/go/","title":"go"},{"content":"python库 pydantic pydantic 是一个用于数据验证和数据序列化的 Python 库，它提供了一个基于类型注释的数据模型定义方式，可以帮助开发者轻松地定义和验证数据模型。以下是 pydantic 库的一些常用功能和用法示例。\n1. 定义数据模型 使用 pydantic 定义数据模型时，可以通过继承 pydantic.BaseModel 类并使用类型注释来定义类的成员变量。例如：\n1 2 3 4 5 6  from pydantic import BaseModel class User(BaseModel): id: int name: str email: str   定义一个字段是字典的数据结构模型，如下：\n1 2 3 4 5  {\u0026#39;type\u0026#39;: \u0026#39;survey\u0026#39;, \u0026#39;content\u0026#39;: {\u0026#39;abstract\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;reason\u0026#39;: \u0026#39;\u0026#39;, \u0026#39;solution\u0026#39;: \u0026#39;\u0026#39;}} # 字典里面嵌套了字典   可以把那个是字典的字段定义为一个BaseModel类就可以了。\n1 2 3 4 5 6 7 8 9 10 11 12  # 定义一个content pydantic数据结构 class Content(BaseModel): abstract: str = Field(..., description=\u0026#34;abstract\u0026#34;) reason: str = Field(..., description=\u0026#34;reason\u0026#34;) solution: str = Field(..., description=\u0026#34;solution\u0026#34;) # summary数据结构 class Summary(BaseModel): type: str = Field(..., description=\u0026#34;summary type\u0026#34;) content: Content = Field(..., description=\u0026#34;summary content\u0026#34;) # 此时的Summary类就是最终想要的答案   2. 验证数据模型 使用 pydantic 验证数据模型时，可以通过创建一个类的实例并传入要验证的数据来验证数据模型的正确性。例如：\n1 2 3 4 5 6  user_data = { \u0026#39;id\u0026#39;: \u0026#39;1\u0026#39;, # 注意这里将 id 赋值为字符串类型，不符合定义 \u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;email\u0026#39;: \u0026#39;alice@example.com\u0026#39; } user = User(**user_data)   这个示例中，user_data 是一个包含用户数据的字典，其中 id 键的值为字符串类型。在创建 User 类的实例时，pydantic 会根据定义的类型注释和传入的数据对数据模型进行验证。由于 id 的定义是整型，而实际传入的值是字符串类型，所以会抛出一个 ValueError 异常，提示 id 的类型不正确。\n3. 序列化数据模型 使用 pydantic 序列化数据模型时，可以通过将一个数据模型对象转换为字典或 JSON 格式的字符串来实现。例如：\n1 2 3 4 5 6 7  user = User(id=1, name=\u0026#39;Alice\u0026#39;, email=\u0026#39;alice@example.com\u0026#39;) # 转换为字典 user_dict = user.dict() # 转换为 JSON 字符串 user_json = user.json()   4. padantic的validator pydantic 库中的 validator 是用于定义数据模型的验证规则的装饰器。通过 validator 装饰器，我们可以在数据模型定义中为一个或多个成员变量添加自定义的验证函数，来验证这些成员变量的取值是否合法。以下是一个 validator 装饰器的使用示例：\n1 2 3 4 5 6 7 8 9 10 11  from pydantic import BaseModel, validator class Person(BaseModel): name: str age: int @validator(\u0026#39;age\u0026#39;) def check_age(cls, value): if value \u0026lt; 0: raise ValueError(\u0026#39;Age must be non-negative\u0026#39;) return value   在这个示例中，Person 类定义了两个成员变量 name 和 age，分别为字符串类型和整型。使用 @validator(\u0026lsquo;age\u0026rsquo;) 装饰器为 age 成员变量添加了一个名为 check_age 的验证函数。check_age 函数接受一个参数 value，表示要验证的值。如果这个值小于 0，则抛出一个 ValueError 异常，提示年龄必须为非负数。否则，返回原始值。\n使用 validator 装饰器时，需要指定要验证的成员变量名。可以通过以下方式指定要验证多个成员变量：\n1 2 3 4 5  @validator(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) def check_person(cls, values): name, age = values # 进行验证逻辑 return values   在这个示例中，check_person 函数接受一个参数 values，它是一个字典，包含了要验证的所有成员变量的键值对。可以通过解包字典的方式来获取每个成员变量的值，并进行验证。\nvalidator 装饰器还支持在整个数据模型上进行验证，而不仅限于单个成员变量。可以通过在类定义上使用 @root_validator 装饰器来实现这个功能。例如：\n1 2 3 4 5 6 7 8 9 10 11 12  class Person(BaseModel): name: str age: int @root_validator def check_person(cls, values): name, age = values.get(\u0026#39;name\u0026#39;), values.get(\u0026#39;age\u0026#39;) if age \u0026lt; 0: raise ValueError(\u0026#39;Age must be non-negative\u0026#39;) if not name: raise ValueError(\u0026#39;Name must not be empty\u0026#39;) return values   在这个示例中，@root_validator 装饰器用于为整个数据模型添加一个验证函数。check_person 函数接受一个参数 values，它是一个字典，包含了所有成员变量的键值对。在这个示例中，check_person 函数对 name 和 age 进行了验证，如果发现不合法的值，则抛出一个 ValueError 异常。否则，返回原始的字典。\nvalidator装饰器还有非常重要的作用是可以把参数做一个转换，比如钱包地址，可以把钱包地址自动转为小写的。如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  from fastapi import FastAPI from pydantic import BaseModel, validator app = FastAPI() class Wallet(BaseModel): wallet_address: str @validator(\u0026#39;wallet_address\u0026#39;, pre=True) def convert_to_lowercase(cls, wallet_address: str) -\u0026gt; str: # 这里会自动把钱包地址转换为小写 return wallet_address.lower() @app.post(\u0026#34;/wallet\u0026#34;) async def create_wallet(wallet: Wallet): return {\u0026#34;wallet_address\u0026#34;: wallet.wallet_address}   fastapi 设置请求头中的key-value时，要保证key的合法性，不合法会出现422 Unprocessable Entity。\n学习知识点：依赖注入, Path, Query, Header, Body\npeewee库 拿到数据库中的一张表的数据的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  from peewee import * # 这个db可以在其他地方初始化好 db = SqliteDatabase(\u0026#39;people.db\u0026#39;) class Person(Model): name = CharField() birthday = DateField() class Meta: database = db # This model uses the \u0026#34;people.db\u0026#34; database. # 使用外部的键值关系, owner不是people.db中的 class Pet(Model): owner = ForeignKeyField(Person, backref=\u0026#39;pets\u0026#39;) name = CharField() animal_type = CharField() class Meta: database = db # this model uses the \u0026#34;people.db\u0026#34; database   1. 存储数据 1 2 3 4 5 6 7 8 9  from datetime import date uncle_bob = Person(name=\u0026#39;Bob\u0026#39;, birthday=date(1960, 1, 15)) uncle_bob.save() # bob is now stored in the database # 也可以使用create创建实例 grandma = Person.create(name=\u0026#39;Grandma\u0026#39;, birthday=date(1935, 3, 1)) herb = Person.create(name=\u0026#39;Herb\u0026#39;, birthday=date(1950, 5, 5))   2. 检索数据库 1. 获取单个记录 1 2 3 4  grandma = Person.select().where(Person.name == \u0026#39;Grandma L.\u0026#39;).get() # 上面的代码等价于 grandma = Person.get(Person.name == \u0026#39;Grandma L.\u0026#39;)   ","date":"2023-05-04T00:00:00Z","permalink":"https://jhrsya.github.io/p/python/","title":"python库介绍"},{"content":"区块链概念 交易哈希 在区块链中，交易哈希（Transaction Hash）是对一笔交易进行哈希计算得到的结果。交易哈希是一个固定长度的字符串，通常是一个64个字符的十六进制字符串。64 * 4 = 256 bit。\n交易哈希是区块链中的一个重要概念，因为它可以唯一地标识一笔交易。在区块链中，每个交易都会被广播到网络中，然后由矿工进行打包，并最终被加入到区块链上。在这个过程中，交易哈希起到了关键的作用。\n每个区块链节点都可以通过交易哈希来验证一笔交易的合法性。当一个节点接收到一个新的交易时，它会首先对这个交易进行哈希计算，然后将计算出的哈希值与已有的交易哈希进行比对，来判断这笔交易是否已经存在于区块链上。\n交易哈希还可以用来追踪一笔交易的状态。在区块链上，每一笔交易都有一个对应的交易哈希，并且交易哈希会被写入到区块链上。当一笔交易被确认并加入到区块链上时，它的交易哈希也会被写入到区块链中，并且成为区块链中的一部分。这样，任何人都可以通过交易哈希来查看一笔交易的状态，并且确认这笔交易是否已经被确认并写入到区块链上。\n发送方地址和接收方地址 在区块链中，发送方地址是由公钥经过哈希运算得到的。具体来说，发送方会使用自己的私钥对交易信息进行数字签名，并将签名和公钥一起发送给网络。接收方可以使用公钥来验证数字签名的有效性，并确认这笔交易确实是由发送方发起的。发送方地址就是通过对公钥进行哈希运算得到的，它可以用来标识发送方。\n和交易哈希一样，也是一个64个字符的十六进制串，共256bit。\n零知识证明 零知识证明是在不披露声明本身的情况下，验证声明有效性的一种方法。 证明者是试图证明声明的一方，而验证者负责验证声明。\n零知识证明来保护数字版权：\n 音乐家创建一个数字签名，将其作为证明。 音乐家使用离散对数算法生成一个随机数，将其作为挑战。 音乐家使用随机数和签名计算出响应，响应是一个整数。 音乐家将签名、挑战和响应发送给验证者。 验证者使用公钥和挑战计算出响应的期望值，并比较期望值和实际响应是否一致。如果一致，就认为签名有效，否则认为签名无效。  女巫攻击 女巫攻击是指一个用户或一个用户群体假装成许多用户。\n共识机制 共识机制分为工作量证明和权益证明。\n挖矿 向区块链中添加现有区块。\n工作量证明(PoW) proof of work. 工作量证明是一种基础性算法，它为矿工在工作量证明区块链上的工作设置难度和规则。\n权益证明 在权益证明机制下，验证者明确的通过以太币将资本质押到以太币的智能合约中。这些质押的以太币充当抵押品，如果验证者有失信行为或消极怠工，那么可以销毁抵押品。\n智能合约 GASPER Gasper是一种定义验证者如何受到奖惩的机制，决定要接受和拒绝哪个区块，以及将区块建在哪个区块链分叉上。\nERC20 ERC20是以太坊（Ethereum）上的一种智能合约标准，它规定了代币合约必须实现的一组函数接口。这些接口包括代币总量、转账功能、余额查询等。使用这些标准化接口可以确保代币合约之间的互操作性，使得不同的代币合约可以在以太坊上无缝地交互。\nERC20标准的实现非常简单，因此成为大量代币合约实现的首选标准。目前市场上绝大多数的代币合约都是基于ERC20标准实现的。使用ERC20标准可以方便钱包、交易所等服务对代币进行支持，也可以降低开发者的开发难度和成本。\nABI 合约的应用程序二进制接口 (ABI)\nERC-20 ERC-20 提出了一个同质化代币的标准，换句话说，它们具有一种属性，使得每个代币都与另一个代币（在类型和价值上）完全相同。 例如，一个 ERC-20 代币就像以太币一样，意味着一个代币会并永远会与其他代币一样。\nERC-20 的功能示例包括：\n 将代币从一个帐户转到另一个帐户 获取帐户的当前代币余额 获取网络上可用代币的总供应量 批准一个帐户中一定的代币金额由第三方帐户使用  智能合约的结构  数据 任何合约数据必须分配到一个位置：要么是存储，要么是内存。 环境变量 函数 事件和日志  zkRollup特性 zkRollup 是一种在以太坊上扩展网络吞吐量和降低交易费用的第二层解决方案。它使用零知识证明 (zk-SNARKs) 技术来在链下聚合多笔交易，然后将它们的证明提交到链上。以下是 zkRollup 的一些主要特性：\n  安全性：zkRollup 继承了以太坊的安全性，因为它将所有数据都放在链上，并使用智能合约来验证和处理交易。这样，即使验证者集合（validator set）完全崩溃，用户也可以直接从链上恢复他们的资产。\n  扩展性：zkRollup 可以显著提高以太坊的交易吞吐量。因为大部分计算工作在链下完成，每个以太坊区块能够包含数千笔 zkRollup 交易。这大大提高了以太坊的网络吞吐量。\n  低成本：zkRollup 交易的费用比以太坊主链的费用低得多，因为它们在链下聚合并进行计算，只需将结果的证明提交到链上。此外，由于所有交易数据都存储在链上，所以存储成本也较低。\n  互操作性：zkRollup 支持所有以太坊的智能合约和标准。这意味着开发者可以无缝地将他们的 dApps 移动到 zkRollup，用户也可以使用他们熟悉的工具（例如 Metamask）来与 zkRollup 进行交互。\n  用户体验：zkRollup 交易的确认时间比以太坊主链快得多，因为它们在链下即时确认。这使得用户体验更接近于传统的支付系统。\n  隐私：zkRollup 可以支持具有隐私特性的应用，因为它使用零知识证明，可以在不泄露任何关于交易的具体细节的情况下验证交易的有效性。\n  总的来说，zkRollup 是一个非常有潜力的扩容技术，它能够将以太坊扩展到全球范围的支付和智能合约平台，同时保持其去中心化和安全性的优点。\nERC721 非同质化代币标准。\n1 2 3 4 5 6 7 8 9  contract ERC721 { event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); function balanceOf(address _owner) external view returns (uint256); function ownerOf(uint256 _tokenId) external view returns (address); function transferFrom(address _from, address _to, uint256 _tokenId) external payable; function approve(address _approved, uint256 _tokenId) external payable; }   ","date":"2023-04-23T00:00:00Z","permalink":"https://jhrsya.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE/","title":"区块链概念"},{"content":"在linux服务器上使用hugo生成静态网站  安装hugo apt-get install hugo 创建新站点 hugo new site \u0026lt;site-name\u0026gt; 下载站点主题 网站 以主题stack为例 链接 可以通过下载quickstart来实现快速配置 下载下来后，可以直接使用hugo server -D来查看效果。 要在本地浏览器中打开，必须要使用ssh -L 1313:localhost:1313 \u0026lt;username\u0026gt;@\u0026lt;server-ip\u0026gt;来建立一个通道，此时可以打开localhost:1313查看网站demo。  ","date":"2022-03-06T00:00:00Z","image":"https://jhrsya.github.io/p/hugo/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://jhrsya.github.io/p/hugo/","title":"hugo-starter 生成静态页面"}]