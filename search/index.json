[{"content":"postgresql postgresql下载与配置 ubantu下载postgresql:\n1 2  sudo apt update sudo apt install postgresql   如何需要让远程的主机连接上服务器上的postgresql，需要设置/etc/postgresql/14/main/postgresql.conf和/etc/postgresql/14/main/pg_hba.conf中的两个文件\n把/etc/postgresql/14/main/postgresql.conf中的listen_address设置为listen_addresses = '*', 把/etc/postgresql/14/main/pg_hba.conf修改为\n1 2  # IPv4 local connections: host all all 0.0.0.0/0 trust   接着重启服务sudo systemctl restart postgresql 或者不重启重新载入配置文件sudo systemctl reload postgresql \npostgresql操作 使用psql进入后的操作  执行sql文件  1  \\i path # path必须是/或者\\\\连接，不能使用\\   查看数据库中有多少张表 \\d 查看表的结构 \\d table_name  使用peewee操作postgresql的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  # 查询所有的用户 users = User.select() # 查询指定条件的用户,可以使用filter也可以使用where users = User.select().where(User.username == \u0026#39;john\u0026#39;) \u0026#34;\u0026#34;\u0026#34; filter()方法是一个查询构建器的方法，它用于向现有查询中添加筛选条件，并返回一个新的查询对象。 where()方法是查询对象的方法，用于指定查询条件。与filter()方法不同，它会直接修改当前查询对象，并返回自身。 \u0026#34;\u0026#34;\u0026#34; new_query = query.filter(User.age \u0026gt; 18) query.where(User.age \u0026gt; 18) # 对查询结果进行排序 users = User.select().order_by(User.username.desc()) # 对查询结果进行分页 users = User.select().paginate(1, 10) # 对查询结果进行聚合操作 from peewee import fn total_users = User.select(fn.COUNT(User.id)) # 使用Peewee的ORM方法进行数据库操作 user = User.create(username=\u0026#39;john\u0026#39;, email=\u0026#39;john@example.com\u0026#39;, password=\u0026#39;password\u0026#39;) # 使用Peewee的ORM方法更新数据库中的记录 user.email = \u0026#39;john@newemail.com\u0026#39; user.save() # 使用Peewee的ORM方法删除数据库中的记录 user.delete_instance()   ","date":"2023-05-05T00:00:00Z","permalink":"https://jhrsya.github.io/p/postgresql/","title":"postgresql介绍"},{"content":"一致性哈希算法 一致性哈希算法（Consistent Hashing）是一种常用的分布式哈希算法，通常用于实现负载均衡和缓存系统，特别是在大规模的分布式系统中。以下是一些可能使用一致性哈希算法的示例：\n 缓存系统：在缓存系统中，一致性哈希算法可以用来选择缓存节点，以便快速存储和检索数据。一致性哈希算法可以使缓存系统中的缓存节点数量变化时，尽可能减少缓存节点的重新分配。 负载均衡：在负载均衡中，一致性哈希算法可以用来选择服务器，以便将客户端请求均匀地分配到各个服务器上。使用一致性哈希算法可以保持服务器数量的变化，而不需要重新分配所有的请求。 分布式文件系统：在分布式文件系统中，一致性哈希算法可以用来选择节点，以便将文件分配到不同的节点上。一致性哈希算法可以避免在节点数量发生变化时，需要重新分配文件的问题。 分布式数据库：在分布式数据库中，一致性哈希算法可以用来选择节点，以便将数据分配到不同的节点上。一致性哈希算法可以避免在节点数量发生变化时，需要重新分配数据的问题。  总之，一致性哈希算法可以用于任何需要在分布式系统中动态分配和选择节点的场景，以便实现高效的负载均衡和分布式存储。\n一致性哈希算法在nginx中的应用 Nginx是一种流行的Web服务器和反向代理服务器，它也被广泛用于负载均衡和高可用性的应用程序中。\n在Nginx中，一致性哈希算法通常用于实现基于IP地址或其他请求参数的负载均衡。具体来说，Nginx可以使用一致性哈希算法来选择服务器，以便将请求路由到正确的服务器上。\n在Nginx的一致性哈希实现中，可以使用一致性哈希模块来实现。该模块可以将请求的哈希值映射到一组服务器中的一个，以实现负载均衡。一致性哈希模块还可以支持动态添加或删除服务器，并保持负载均衡策略的一致性。\n哈希函数 Nginx使用了MurmurHash哈希函数来计算键的哈希值。MurmurHash是一种高效的哈希函数，它在计算哈希值时可以避免哈希碰撞。\nMurmurHash是一种快速的非加密哈希函数，它的设计旨在提供良好的随机性、均匀性和高性能。MurmurHash的哈希算法比其他常见的哈希算法如MD5和SHA-1要快得多，并且在分布式系统中的负载均衡和数据分片中被广泛使用。\nMurmurHash算法的主要思想是利用位操作和乘法来处理输入数据，并使用分离的哈希状态来生成哈希值。具体来说，MurmurHash算法将输入数据按照一定的规则分割成若干个32位的块，每个块都会对哈希状态进行更新，然后将最终的哈希状态转换为哈希值输出。\n举个例子，如果一个来了一个ip地址请求，murmurhash是如何处理的？\n  初始化哈希状态 MurmurHash算法使用两个32位的常量来初始化哈希状态，其中一个常量是随机选择的，另一个常量是固定的。假设我们选择的随机常量为0x5bd1e995，固定常量为0x9747b28c。\n  处理输入数据 我们将IP地址按照一定的规则转换为32位整数，并将其作为输入数据。假设IP地址为192.168.1.100，对应的32位整数为0xc0a80164。根据MurmurHash算法的规则，我们需要将这个32位整数按照如下方式处理:\n 将32位整数分为四个8位的字节，即0xc0、0xa8、0x01和0x64。 将每个字节转换为32位整数，即0x000000c0、0x000000a8、0x00000001和0x00000064。 将这些32位整数按照一定的规则进行位运算和乘法，生成一个新的32位整数。假设这个新的32位整数为0x3f6e3d6f。  我们将生成的新的32位整数0x3f6e3d6f作为输入数据，对哈希状态进行更新。具体来说，我们将新的32位整数作为参数，调用一个哈希状态更新函数，该函数会对哈希状态进行混合，使得哈希状态随着输入数据的变化而变化。\n  结束哈希状态 当输入数据处理完成时，我们使用一些位运算和乘法来结束哈希状态。具体来说，我们对哈希状态进行一些最终的混合和变换，使得哈希状态满足一定的分布特性。\n  生成哈希值 最后，我们将哈希状态转换为哈希值输出。通常情况下，哈希值会被截取为固定长度的位数，并进行适当的调整和变换，以保证其满足特定的需求。假设我们将哈希值截取为16位，即0x3d6f，作为IP地址的哈希值。\n  在负载均衡场景中，我们可以使用IP地址的哈希值来决定该请求应该由哪个服务器来处理。\n一致性哈希环 Nginx使用了一致性哈希环来存储服务器节点和键的哈希值。服务器节点在环上分布，并且每个键都可以映射到一个服务器节点。这种设计可以使负载均衡策略在添加或删除服务器时保持一致性。\n一致性哈希环是一种数据结构，用于实现一致性哈希算法。它由一个环形结构组成，每个节点在环上对应一个哈希值，表示一个服务器或者节点。通常情况下，哈希值是一个整数，通常使用32位或64位无符号整数。\n一致性哈希环的构建过程如下：\n  计算服务器哈希值 对于每个服务器，使用哈希算法计算其哈希值。通常情况下，可以使用服务器的IP地址或者主机名作为输入数据进行哈希，以保证每个服务器的哈希值是唯一的。\n  在环上分配节点 将所有的服务器节点按照其哈希值，在环上分配节点。通常情况下，可以使用哈希值对环进行分片，每个节点对应一个分片。分片的数量可以根据具体情况进行调整，通常情况下，分片的数量应该比较大，以保证分布均匀。\n  计算对象哈希值 对于每个对象，使用哈希算法计算其哈希值。通常情况下，可以使用对象的ID或者键值作为输入数据进行哈希，以保证每个对象的哈希值是唯一的。\n  在环上查找节点 将对象的哈希值映射到环上的某个节点。具体来说，从对象的哈希值开始沿着环顺时针方向查找，找到第一个大于等于该哈希值的节点。如果没有找到该节点，则将对象映射到环上的第一个节点。\n  一致性哈希环的优点是可以动态添加或删除服务器节点，而不会影响大部分对象的映射。具体来说，当添加或删除一个服务器节点时，只有该节点周围的对象映射会发生变化，其他节点的对象映射仍然保持不变。这样可以避免大量对象的重新映射，提高一致性哈希算法的效率和可扩展性。\n一致性哈希环还可以使用虚拟节点技术来提高负载均衡的效率和稳定性。具体来说，对于每个服务器节点，可以在环上分配多个虚拟节点，每个虚拟节点对应一个哈希值。这样可以使得服务器节点在环上的分布更加均匀，从而提高负载均衡的效率和稳定性。\n节点选择 当一个请求到达时，Nginx会计算请求键的哈希值，并将其映射到一致性哈希环上。然后，Nginx会选择最近的服务器节点，并将请求转发到该节点上。如果该节点不可用，则Nginx会选择下一个最近的节点。\n动态添加或删除服务器 在Nginx的一致性哈希模块中，可以动态添加或删除服务器，并保持负载均衡策略的一致性。当添加或删除服务器时，Nginx会重新计算哈希环，并将请求转发到新的服务器节点。\n","date":"2023-05-05T00:00:00Z","permalink":"https://jhrsya.github.io/p/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/","title":"一致性哈希算法"},{"content":"cpp 关键字 1. volatile volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。\n2. override 告诉编译器一定是重写了父类的函数，不然就会报错。\n1 2 3 4 5 6 7 8 9  class A { virtual void foo(); }; class B : public A { virtual void f00(); //OK，这个函数是B新增的，不是继承的  virtual void f0o() override; //Error, 加了override之后，这个函数一定是继承自A的，A找不到就报错 };   3. final 当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Base { virtual void foo(); }; class A : public Base { void foo() final; // foo 被override并且是最后一个override，在其子类中不可以重写 }; class B final : A // 指明B是不可以被继承的 { void foo() override; // Error: 在A中已经被final了 }; class C : B // Error: B is final { };   4. explicit explicit修饰构造函数时，如果构造函数存在隐式转换，编译时会报错。只能显示的使用构造函数。\n5. static 当static用于变量时，它可以用于控制变量的可见范围。具体来说，如果一个变量被声明为static，那么它只能在当前文件中使用，而无法被其他文件访问。这样可以防止变量被意外修改或者在不同的文件中出现命名冲突。\n当static用于函数时，它可以用于控制函数的可见范围。具体来说，如果一个函数被声明为static，那么它只能在当前文件中使用，而无法被其他文件调用。这样可以确保函数只被用于当前文件，避免了函数名冲突和重复定义的问题。\n需要注意的是，static还可以用于类的成员变量和成员函数，此时它的作用类似于在全局作用域下的变量和函数。对于static成员变量，所有类的实例都共享同一个变量，对它的修改会影响所有实例。对于static成员函数，它不会访问任何实例数据，也不需要this指针，因此可以直接通过类名来调用。\n拷贝构造函数和拷贝赋值函数 都是将一个对象的值复制给另一个对象；但是其结果却有些不同，拷贝构造函数使用传入对象的值生成一个新的对象的实例，而赋值运算符是将对象的值复制给一个已经存在的实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  #include \u0026lt;cstring\u0026gt; class MyString { public: // 构造函数  MyString() { m_data = new char[1]; *m_data = \u0026#39;\\0\u0026#39;; } MyString(const char* str) { if (str == nullptr) { m_data = new char[1]; *m_data = \u0026#39;\\0\u0026#39;; } else { int len = strlen(str); m_data = new char[len + 1]; strcpy(m_data, str); } } // 拷贝构造函数  MyString(const MyString\u0026amp; other) { int len = strlen(other.m_data); m_data = new char[len + 1]; strcpy(m_data, other.m_data); } // 拷贝赋值函数  MyString\u0026amp; operator=(const MyString\u0026amp; other) { if (this != \u0026amp;other) { char* tmp = new char[strlen(other.m_data) + 1]; strcpy(tmp, other.m_data); delete[] m_data; m_data = tmp; } return *this; } // 析构函数  ~MyString() { delete[] m_data; } private: char* m_data; };   野指针和悬空指针 野指针：没有被初始化的指针。 悬空指针：最初指向的内存已经被释放了的一种指针。\n产生原因及解决办法： 野指针：指针变量未及时初始化 =\u0026gt; 定义指针变量及时初始化，要么置空。 悬空指针：指针free或delete之后没有及时置空 =\u0026gt; 释放操作后立即置空。\n内联函数和宏定义的区别  在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。 宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义。 内联函数有类型检测、语法判断等功能，而宏没有。  内联函数适用场景:\n 使用宏定义的地方都可以使用 inline 函数。 作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。  在 Java 中，可以使用关键字 final 来修饰方法，使其成为 final 方法，从而在编译期间实现类似于 inline 函数的效果。final 方法在编译期间会被直接替换到调用该方法的地方，而不是像普通方法一样需要在运行时才能动态绑定。\n在 Go 语言中，没有类似于 C++ 中的 inline 关键字，但是 Go 编译器会在适当的情况下自动将函数内联。Go 编译器会在编译时进行函数内联，这样可以减少函数调用的开销，提高程序的执行效率。\nvolatile、mutable和explicit关键字的用法 volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。\nmutable表示可变的，在常函数里也可以被修改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  class person { int m_A; mutable int m_B;//特殊变量 在常函数里值也可以被修改 public: void add() const//在函数里不可修改this指针指向的值 常量指针  { m_A=10;//错误 不可修改值，this已经被修饰为常量指针  m_B=20;//正确  } } class person { int m_A; mutable int m_B;//特殊变量 在常函数里值也可以被修改 } int main() { const person p;//修饰常对象 不可修改类成员的值 p.m_A=10;//错误，被修饰了指针常量 p.m_B=200;//正确，特殊变量，修饰了mutable }   explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换，注意以下几点：\n explicit 关键字只能用于类内部的构造函数声明上 explicit 关键字作用于单个参数的构造函数 被explicit修饰的构造函数的类，不能发生相应的隐式类型转换  RAII(资源获取即初始化) 原因：在对象初始化时，如果调用构造函数时发生了异常，这之前已经调用了operator new函数分配了内存，那么就会导致内存泄漏，解决方法是使用try-catch块来捕获构造函数中的异常，并在发生异常时显式地调用 operator delete 函数以释放已分配的内存。\n但是上面的解决方案显然太麻烦，可以使用RAII来解决这个问题。 RAII（资源获取即初始化）是一种C++编程技术，它利用了对象的生命周期来管理资源。通过在对象的构造函数中获取资源，在对象的析构函数中释放资源，可以确保在任何情况下都能正确地释放资源，从而避免内存泄漏等问题。\n当 RAII 对象被创建时，构造函数被调用，并分配了相应的资源；当 RAII 对象超出作用域时，析构函数被自动调用，以释放之前分配的资源。如果构造函数中发生异常，则该 RAII 对象的构造未能成功完成，因此该对象不应该继续存在。因此，C++ 编译器会自动调用析构函数来清理该对象占用的资源。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  class Resource { public: Resource() { // 分配内存  m_data = new int[100]; } ~Resource() { // 释放内存  delete[] m_data; } private: int* m_data; }; class MyClass { public: MyClass() { // 在构造函数中使用资源管理类分配内存  m_resource = new (std::nothrow) Resource; if (!m_resource) { // 处理内存分配失败的情况  throw std::bad_alloc(); } } ~MyClass() { // 在析构函数中释放内存  delete m_resource; } private: Resource* m_resource; };   在上面的代码中，我们使用了 C++11 中的 std::nothrow，它表示如果内存分配失败不会抛出异常，而是返回一个空指针。如果内存分配失败，我们可以在构造函数中处理这种情况，例如抛出 std::bad_alloc 异常，然后外部的代码就可以根据需要进行处理。\n零拷贝 零拷贝是一种技术，它可以在不复制数据的情况下，在不同的进程或线程之间传输数据。 零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。 零拷贝技术可以减少数据拷贝和共享总线操作的次数。 在C++中，vector的一个成员函数**emplace_back()**很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：使用push_back()函数需要调用构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发构造函数和转移构造函数，效率更高。举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  #include \u0026lt;vector\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;iostream\u0026gt;using namespace std; struct Person { string name; int age; //初始构造函数  Person(string p_name, int p_age): name(std::move(p_name)), age(p_age) { cout \u0026lt;\u0026lt; \u0026#34;I have been constructed\u0026#34; \u0026lt;\u0026lt;endl; } //拷贝构造函数  Person(const Person\u0026amp; other): name(std::move(other.name)), age(other.age) { cout \u0026lt;\u0026lt; \u0026#34;I have been copy constructed\u0026#34; \u0026lt;\u0026lt;endl; } //转移构造函数  Person(Person\u0026amp;\u0026amp; other): name(std::move(other.name)), age(other.age) { cout \u0026lt;\u0026lt; \u0026#34;I have been moved\u0026#34;\u0026lt;\u0026lt;endl; } }; int main() { vector\u0026lt;Person\u0026gt; e; cout \u0026lt;\u0026lt; \u0026#34;emplace_back:\u0026#34; \u0026lt;\u0026lt;endl; e.emplace_back(\u0026#34;Jane\u0026#34;, 23); //不用构造类对象  vector\u0026lt;Person\u0026gt; p; cout \u0026lt;\u0026lt; \u0026#34;push_back:\u0026#34;\u0026lt;\u0026lt;endl; p.push_back(Person(\u0026#34;Mike\u0026#34;,36)); return 0; } //输出结果： //emplace_back: //I have been constructed //push_back: //I have been constructed //I am being moved.   右值 右值引用使用 \u0026amp;\u0026amp; 符号表示。 在 C++ 中，右值指的是那些在表达式求值期间创建的临时对象、字面常量、表达式、返回右值引用的函数调用等，它们都是临时的、短暂的，不能被持久化或修改，因此右值只能被拷贝或移动，不能被赋值或取地址。 右值引用通常用于实现移动语义和完美转发。移动语义可以避免在资源管理类中进行不必要的复制操作，提高程序的性能。完美转发可以实现将参数按原样传递给下一层函数，同时避免不必要的复制操作。 举个完美转发的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #include \u0026lt;iostream\u0026gt;#include \u0026lt;utility\u0026gt; void foo(int \u0026amp;x) { std::cout \u0026lt;\u0026lt; \u0026#34;foo(int\u0026amp;): \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } void foo(int \u0026amp;\u0026amp;x) { std::cout \u0026lt;\u0026lt; \u0026#34;foo(int\u0026amp;\u0026amp;): \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } template\u0026lt;typename T\u0026gt; void bar(T \u0026amp;\u0026amp;x) { foo(std::forward\u0026lt;T\u0026gt;(x)); } int main() { int x = 42; bar(x); // 输出 foo(int\u0026amp;): 42  bar(3); // 输出 foo(int\u0026amp;\u0026amp;): 3  bar(std::move(x)); // 输出 foo(int\u0026amp;\u0026amp;): 42 完美转发  return 0; }   组合 是has-a的关系。 在C++中，组合（Composition）是一种面向对象编程的概念，指的是一个类（称为容器类）包含另外一个类（称为成员类）的对象作为自己的成员。组合实现了代码的复用，使得一个类可以重用另一个类的实现而不必从头开始编写代码。\n通过组合，一个类可以将另一个类的功能集成到自己的功能中。例如，一个汽车类可以包含一个引擎类的对象，从而实现汽车的动力系统。另一个例子是，一个图形类可以包含一个点类的对象，从而实现图形的定位和形状。\n在C++中，组合的实现方式是将成员对象作为容器类的私有成员变量。容器类可以通过调用成员对象的公共接口来访问和操作成员对象的状态和行为。由于成员对象是容器类的一部分，因此成员对象的生命周期和容器类的生命周期是一样的。\n函数指针 函数指针是指向函数的指针变量，可以用来存储和调用函数。在C++中，函数名可以视为一个指向函数的指针，因此可以将函数名赋值给一个函数指针变量，然后通过该变量来调用函数。 函数指针的语法如下：return-type (*pointer-name)(argument-list);\n函数指针可以用来传递函数作为参数，或者用来返回函数作为返回值。这在一些高级的编程场景中非常有用，例如回调函数、函数对象等。 函数对象是一种将函数封装为对象的技术。通过函数对象，可以将函数与数据结构相结合，形成一个新的数据类型，从而实现更加灵活的程序设计。函数对象广泛应用于标准模板库（STL）中，例如在算法中传递比较函数、排序函数等。\n举例如何使用函数指针来实现回调函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #include \u0026lt;iostream\u0026gt;using namespace std; // 加法函数 int add(int a, int b) { return a + b; } // 减法函数 int subtract(int a, int b) { return a - b; } // 计算函数 int calculate(int a, int b, int (*p)(int, int)) { return p(a, b); } int main() { int a = 3, b = 4; int result; // 使用加法函数进行计算  result = calculate(a, b, add); cout \u0026lt;\u0026lt; \u0026#34;Addition result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; // 使用减法函数进行计算  result = calculate(a, b, subtract); cout \u0026lt;\u0026lt; \u0026#34;Subtraction result: \u0026#34; \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; return 0; }   内存对齐 内存对齐（Memory Alignment）是指在计算机中为了提高数据读取效率而采取的一种数据对齐方式。在C++中，编译器会根据结构体中成员变量的数据类型和顺序来决定如何分配内存，以保证每个成员变量被正确地对齐。具体来说，对于每个成员变量，编译器会将其分配在地址可以被其大小整除的位置上，以确保读取时能够高效地访问。\n内存对齐可以提高数据读取效率的原因是，当数据被存储到内存中时，计算机通常会将数据一次性读取到缓存中，以便快速访问。如果数据没有按照特定的对齐方式存储在内存中，读取时就需要额外的处理，从而导致读取效率降低。\n共享内存的实现方式 共享内存是指多个进程可以同时访问同一个物理内存区域，它是实现进程间通信的一种方式，可以提高进程间通信的效率。\n共享内存的实现方式主要有两种：基于文件和基于匿名映射。\n基于文件的共享内存实现方式：将共享内存映射到一个文件中，多个进程可以通过访问该文件来访问共享内存。具体实现过程如下：\n（1）使用shmget()函数创建或打开一个共享内存对象，并返回一个标识符。 （2）使用shmat()函数将共享内存对象映射到进程的地址空间中。 （3）多个进程可以通过访问共享内存对象所在的文件来访问共享内存。 （4）使用shmdt()函数将共享内存对象从进程的地址空间中分离。 （5）使用shmctl()函数控制共享内存对象。\n基于匿名映射的共享内存实现方式：不需要映射到文件中，直接将共享内存映射到进程的地址空间中。具体实现过程如下：\n（1）使用mmap()函数创建一个匿名映射区域，该区域被多个进程共享。 （2）多个进程可以通过访问该匿名映射区域来访问共享内存。 （3）使用munmap()函数释放匿名映射区域。\n需要注意的是，在使用共享内存时需要考虑进程间同步的问题，以避免数据的不一致性。可以使用信号量等进程间同步机制来保证多个进程对共享内存的访问顺序和正确性。此外，还需要考虑共享内存的大小和释放问题，避免内存泄漏和过度占用内存等问题。\n","date":"2023-05-04T00:00:00Z","permalink":"https://jhrsya.github.io/p/cpp/","title":"cpp_notes"},{"content":"go go不同点：\n go如果声明了变量，那一定要使用，不然会报错 go没有 i++ 和 i-- go 没有返回值不用设置为void ，直接不设置返回值就可以 go 里面切片不能使用负值，比如-1 go中变量名和函数返回值都是写在变量名和函数返回值的后面 go是面向接口编程 go中的const可以定义枚举类型 c++, java抛异常都是用throw, go 用panic, python用raise  go提供的数据结构 1. 数组 var arr [3]int\n2. 切片(slice) 动态数组var arr []int\n3. 映射 map: 底层用哈希表实现 声明并初始化：m := map[string]int {\u0026quot;one\u0026quot;: 1, \u0026quot;two: 2} map的打印顺序是无法确定的，是随机的，是一种无序的键值对集合。 go中没有有序的键值对集合，可以使用slice和struct实现有序的键值对结合。\n关键字 1. make make 是一个用来创建某些类型的引用对象的内建函数。 具体来说，make 用于创建 slice、map 和 channel 类型的对象，而不是创建值类型的对象（例如 int、float 等）。 make后才会分配内存空间。\ngo并发 1. go关键字 Go 允许使用 go 语句开启一个新的运行期线程， 即 goroutine(协程)，以一个不同的、新创建的 goroutine 来执行一个函数。 同一个程序中的所有 goroutine 共享同一个地址空间。\n2. channel关键字 默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。\n如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。\n带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。\n总结：goroutine之间的通信可以通过channel来实现。\ngo面向接口编程 在 Go 语言中，如果要继承一个接口，你只需要在结构体中实现该接口声明的所有方法。 这种依靠实现方法匹配度的继承方式，就是鸭子类型：如果一个动物看起来像鸭子，叫起来也像鸭子，那它一定是鸭子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // 定义 Animal 接口 interface Animal { Eat() // 声明 Eat 方法  Move() // 声明 Move 方法 } // ==== 定义 Dog Start ==== // 定义 Dog 类 type Dog struct { } // 实现 Eat 方法 func (d *Dog) Eat() { fmt.Printf(\u0026#34;Eating bones\u0026#34;) } // 实现 Move 方法 func (d *Dog) Move() { fmt.Printf(\u0026#34;Moving with four legs\u0026#34;) } // ==== 定义 Dog End ====  // ==== 定义 Human Start ==== // 定义 Human 类 type Human struct { } // 实现 Eat 方法 func (h *Human) Eat() { fmt.Printf(\u0026#34;Eating rice\u0026#34;) } // 实现 Move 方法 func (h *Human) Move() { fmt.Printf(\u0026#34;Moving with two legs\u0026#34;) } // ==== 定义 Human End ====   go错误处理 Go 语言要求开发者自己管理错误，也就是在函数中的错误需要显式抛出来，否则 Go 程序不会做任何错误处理。因为 Go 没有传统编程语言的 try/catch 针对错误处理的语法，所以在错误管理上缺少灵活度，导致了 “err 满天飞” 的局面。\ngo错误处理的好处：第一，它强制要求 Go 语言开发者从代码层面来规范错误的管理方式，这驱使开发者写出更健壮的代码；第二，这种显式返回错误的方式避免了 “try/catch 一把梭”，因为这种 “一时爽” 的做法很可能导致 Bug 无法准确定位，从而产生很多不可预测的问题；第三，由于没有 try/catch 的括号或额外的代码块，Go 程序代码整体看起来更清爽，可读性较强。\n","date":"2023-05-04T00:00:00Z","permalink":"https://jhrsya.github.io/p/go/","title":"go"},{"content":"python库 pydantic pydantic 是一个用于数据验证和数据序列化的 Python 库，它提供了一个基于类型注释的数据模型定义方式，可以帮助开发者轻松地定义和验证数据模型。以下是 pydantic 库的一些常用功能和用法示例。\n1. 定义数据模型 使用 pydantic 定义数据模型时，可以通过继承 pydantic.BaseModel 类并使用类型注释来定义类的成员变量。例如：\n1 2 3 4 5 6  from pydantic import BaseModel class User(BaseModel): id: int name: str email: str   2. 验证数据模型 使用 pydantic 验证数据模型时，可以通过创建一个类的实例并传入要验证的数据来验证数据模型的正确性。例如：\n1 2 3 4 5 6  user_data = { \u0026#39;id\u0026#39;: \u0026#39;1\u0026#39;, # 注意这里将 id 赋值为字符串类型，不符合定义 \u0026#39;name\u0026#39;: \u0026#39;Alice\u0026#39;, \u0026#39;email\u0026#39;: \u0026#39;alice@example.com\u0026#39; } user = User(**user_data)   这个示例中，user_data 是一个包含用户数据的字典，其中 id 键的值为字符串类型。在创建 User 类的实例时，pydantic 会根据定义的类型注释和传入的数据对数据模型进行验证。由于 id 的定义是整型，而实际传入的值是字符串类型，所以会抛出一个 ValueError 异常，提示 id 的类型不正确。\n3. 序列化数据模型 使用 pydantic 序列化数据模型时，可以通过将一个数据模型对象转换为字典或 JSON 格式的字符串来实现。例如：\n1 2 3 4 5 6 7  user = User(id=1, name=\u0026#39;Alice\u0026#39;, email=\u0026#39;alice@example.com\u0026#39;) # 转换为字典 user_dict = user.dict() # 转换为 JSON 字符串 user_json = user.json()   4. padantic的validator pydantic 库中的 validator 是用于定义数据模型的验证规则的装饰器。通过 validator 装饰器，我们可以在数据模型定义中为一个或多个成员变量添加自定义的验证函数，来验证这些成员变量的取值是否合法。以下是一个 validator 装饰器的使用示例：\n1 2 3 4 5 6 7 8 9 10 11  from pydantic import BaseModel, validator class Person(BaseModel): name: str age: int @validator(\u0026#39;age\u0026#39;) def check_age(cls, value): if value \u0026lt; 0: raise ValueError(\u0026#39;Age must be non-negative\u0026#39;) return value   在这个示例中，Person 类定义了两个成员变量 name 和 age，分别为字符串类型和整型。使用 @validator(\u0026lsquo;age\u0026rsquo;) 装饰器为 age 成员变量添加了一个名为 check_age 的验证函数。check_age 函数接受一个参数 value，表示要验证的值。如果这个值小于 0，则抛出一个 ValueError 异常，提示年龄必须为非负数。否则，返回原始值。\n使用 validator 装饰器时，需要指定要验证的成员变量名。可以通过以下方式指定要验证多个成员变量：\n1 2 3 4 5  @validator(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;) def check_person(cls, values): name, age = values # 进行验证逻辑 return values   在这个示例中，check_person 函数接受一个参数 values，它是一个字典，包含了要验证的所有成员变量的键值对。可以通过解包字典的方式来获取每个成员变量的值，并进行验证。\nvalidator 装饰器还支持在整个数据模型上进行验证，而不仅限于单个成员变量。可以通过在类定义上使用 @root_validator 装饰器来实现这个功能。例如：\n1 2 3 4 5 6 7 8 9 10 11 12  class Person(BaseModel): name: str age: int @root_validator def check_person(cls, values): name, age = values.get(\u0026#39;name\u0026#39;), values.get(\u0026#39;age\u0026#39;) if age \u0026lt; 0: raise ValueError(\u0026#39;Age must be non-negative\u0026#39;) if not name: raise ValueError(\u0026#39;Name must not be empty\u0026#39;) return values   在这个示例中，@root_validator 装饰器用于为整个数据模型添加一个验证函数。check_person 函数接受一个参数 values，它是一个字典，包含了所有成员变量的键值对。在这个示例中，check_person 函数对 name 和 age 进行了验证，如果发现不合法的值，则抛出一个 ValueError 异常。否则，返回原始的字典。\nfastapi 设置请求头中的key-value时，要保证key的合法性，不合法会出现422 Unprocessable Entity。\n学习知识点：依赖注入, Path, Query, Header, Body\npeewee库 拿到数据库中的一张表的数据的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  from peewee import * # 这个db可以在其他地方初始化好 db = SqliteDatabase(\u0026#39;people.db\u0026#39;) class Person(Model): name = CharField() birthday = DateField() class Meta: database = db # This model uses the \u0026#34;people.db\u0026#34; database. # 使用外部的键值关系, owner不是people.db中的 class Pet(Model): owner = ForeignKeyField(Person, backref=\u0026#39;pets\u0026#39;) name = CharField() animal_type = CharField() class Meta: database = db # this model uses the \u0026#34;people.db\u0026#34; database   1. 存储数据 1 2 3 4 5 6 7 8 9  from datetime import date uncle_bob = Person(name=\u0026#39;Bob\u0026#39;, birthday=date(1960, 1, 15)) uncle_bob.save() # bob is now stored in the database # 也可以使用create创建实例 grandma = Person.create(name=\u0026#39;Grandma\u0026#39;, birthday=date(1935, 3, 1)) herb = Person.create(name=\u0026#39;Herb\u0026#39;, birthday=date(1950, 5, 5))   2. 检索数据库 1. 获取单个记录 1 2 3 4  grandma = Person.select().where(Person.name == \u0026#39;Grandma L.\u0026#39;).get() # 上面的代码等价于 grandma = Person.get(Person.name == \u0026#39;Grandma L.\u0026#39;)   ","date":"2023-05-04T00:00:00Z","permalink":"https://jhrsya.github.io/p/python/","title":"python库介绍"},{"content":"区块链概念 1. 交易哈希 在区块链中，交易哈希（Transaction Hash）是对一笔交易进行哈希计算得到的结果。交易哈希是一个固定长度的字符串，通常是一个64个字符的十六进制字符串。64 * 4 = 256 bit。\n交易哈希是区块链中的一个重要概念，因为它可以唯一地标识一笔交易。在区块链中，每个交易都会被广播到网络中，然后由矿工进行打包，并最终被加入到区块链上。在这个过程中，交易哈希起到了关键的作用。\n每个区块链节点都可以通过交易哈希来验证一笔交易的合法性。当一个节点接收到一个新的交易时，它会首先对这个交易进行哈希计算，然后将计算出的哈希值与已有的交易哈希进行比对，来判断这笔交易是否已经存在于区块链上。\n交易哈希还可以用来追踪一笔交易的状态。在区块链上，每一笔交易都有一个对应的交易哈希，并且交易哈希会被写入到区块链上。当一笔交易被确认并加入到区块链上时，它的交易哈希也会被写入到区块链中，并且成为区块链中的一部分。这样，任何人都可以通过交易哈希来查看一笔交易的状态，并且确认这笔交易是否已经被确认并写入到区块链上。\n2. 发送方地址和接收方地址 在区块链中，发送方地址是由公钥经过哈希运算得到的。具体来说，发送方会使用自己的私钥对交易信息进行数字签名，并将签名和公钥一起发送给网络。接收方可以使用公钥来验证数字签名的有效性，并确认这笔交易确实是由发送方发起的。发送方地址就是通过对公钥进行哈希运算得到的，它可以用来标识发送方。\n和交易哈希一样，也是一个64个字符的十六进制串，共256bit。\n3. 零知识证明 零知识证明是在不披露声明本身的情况下，验证声明有效性的一种方法。 证明者是试图证明声明的一方，而验证者负责验证声明。\n零知识证明来保护数字版权：\n 音乐家创建一个数字签名，将其作为证明。 音乐家使用离散对数算法生成一个随机数，将其作为挑战。 音乐家使用随机数和签名计算出响应，响应是一个整数。 音乐家将签名、挑战和响应发送给验证者。 验证者使用公钥和挑战计算出响应的期望值，并比较期望值和实际响应是否一致。如果一致，就认为签名有效，否则认为签名无效。  4. 女巫攻击 女巫攻击是指一个用户或一个用户群体假装成许多用户。\n5. 共识机制 共识机制分为工作量证明和权益证明。\n6. 挖矿 向区块链中添加现有区块。\n7. 工作量证明(PoW) proof of work. 工作量证明是一种基础性算法，它为矿工在工作量证明区块链上的工作设置难度和规则。\n8. 权益证明 在权益证明机制下，验证者明确的通过以太币将资本质押到以太币的智能合约中。这些质押的以太币充当抵押品，如果验证者有失信行为或消极怠工，那么可以销毁抵押品。\n8. 智能合约 9. GASPER Gasper是一种定义验证者如何受到奖惩的机制，决定要接受和拒绝哪个区块，以及将区块建在哪个区块链分叉上。\n","date":"2023-04-23T00:00:00Z","permalink":"https://jhrsya.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE/","title":"区块链概念"},{"content":"在linux服务器上使用hugo生成静态网站  安装hugo apt-get install hugo 创建新站点 hugo new site \u0026lt;site-name\u0026gt; 下载站点主题 网站 以主题stack为例 链接 可以通过下载quickstart来实现快速配置 下载下来后，可以直接使用hugo server -D来查看效果。 要在本地浏览器中打开，必须要使用ssh -L 1313:localhost:1313 \u0026lt;username\u0026gt;@\u0026lt;server-ip\u0026gt;来建立一个通道，此时可以打开localhost:1313查看网站demo。  ","date":"2022-03-06T00:00:00Z","image":"https://jhrsya.github.io/p/hello-world/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://jhrsya.github.io/p/hello-world/","title":"hugo-starter 生成静态页面"}]